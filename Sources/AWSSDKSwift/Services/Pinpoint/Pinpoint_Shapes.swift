// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/noppoMan/aws-sdk-swift/blob/master/Sources/CodeGenerator/main.swift. DO NOT EDIT.

import Foundation
import AWSSDKSwiftCore

extension Pinpoint {

    public struct ADMChannelRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ClientId", required: false, type: .string), 
            AWSShapeMember(label: "ClientSecret", required: false, type: .string), 
            AWSShapeMember(label: "Enabled", required: false, type: .boolean)
        ]
        /// The Client ID that you obtained from the Amazon App Distribution Portal.
        public let clientId: String?
        /// The Client Secret that you obtained from the Amazon App Distribution Portal.
        public let clientSecret: String?
        /// Indicates whether or not the channel is enabled for sending messages.
        public let enabled: Bool?

        public init(clientId: String? = nil, clientSecret: String? = nil, enabled: Bool? = nil) {
            self.clientId = clientId
            self.clientSecret = clientSecret
            self.enabled = enabled
        }

        private enum CodingKeys: String, CodingKey {
            case clientId = "ClientId"
            case clientSecret = "ClientSecret"
            case enabled = "Enabled"
        }
    }

    public struct ADMChannelResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", required: false, type: .string), 
            AWSShapeMember(label: "CreationDate", required: false, type: .string), 
            AWSShapeMember(label: "Enabled", required: false, type: .boolean), 
            AWSShapeMember(label: "HasCredential", required: false, type: .boolean), 
            AWSShapeMember(label: "Id", required: false, type: .string), 
            AWSShapeMember(label: "IsArchived", required: false, type: .boolean), 
            AWSShapeMember(label: "LastModifiedBy", required: false, type: .string), 
            AWSShapeMember(label: "LastModifiedDate", required: false, type: .string), 
            AWSShapeMember(label: "Platform", required: false, type: .string), 
            AWSShapeMember(label: "Version", required: false, type: .integer)
        ]
        /// The ID of the application to which the channel applies.
        public let applicationId: String?
        /// The date and time when this channel was created.
        public let creationDate: String?
        /// Indicates whether or not the channel is enabled for sending messages.
        public let enabled: Bool?
        /// Not used. Retained for backwards compatibility.
        public let hasCredential: Bool?
        /// (Deprecated) An identifier for the channel. Retained for backwards compatibility.
        public let id: String?
        /// Indicates whether or not the channel is archived.
        public let isArchived: Bool?
        /// The user who last updated this channel.
        public let lastModifiedBy: String?
        /// The date and time when this channel was last modified.
        public let lastModifiedDate: String?
        /// The platform type. For this channel, the value is always "ADM."
        public let platform: String?
        /// The channel version.
        public let version: Int32?

        public init(applicationId: String? = nil, creationDate: String? = nil, enabled: Bool? = nil, hasCredential: Bool? = nil, id: String? = nil, isArchived: Bool? = nil, lastModifiedBy: String? = nil, lastModifiedDate: String? = nil, platform: String? = nil, version: Int32? = nil) {
            self.applicationId = applicationId
            self.creationDate = creationDate
            self.enabled = enabled
            self.hasCredential = hasCredential
            self.id = id
            self.isArchived = isArchived
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedDate = lastModifiedDate
            self.platform = platform
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "ApplicationId"
            case creationDate = "CreationDate"
            case enabled = "Enabled"
            case hasCredential = "HasCredential"
            case id = "Id"
            case isArchived = "IsArchived"
            case lastModifiedBy = "LastModifiedBy"
            case lastModifiedDate = "LastModifiedDate"
            case platform = "Platform"
            case version = "Version"
        }
    }

    public struct ADMMessage: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Action", required: false, type: .enum), 
            AWSShapeMember(label: "Body", required: false, type: .string), 
            AWSShapeMember(label: "ConsolidationKey", required: false, type: .string), 
            AWSShapeMember(label: "Data", required: false, type: .map), 
            AWSShapeMember(label: "ExpiresAfter", required: false, type: .string), 
            AWSShapeMember(label: "IconReference", required: false, type: .string), 
            AWSShapeMember(label: "ImageIconUrl", required: false, type: .string), 
            AWSShapeMember(label: "ImageUrl", required: false, type: .string), 
            AWSShapeMember(label: "MD5", required: false, type: .string), 
            AWSShapeMember(label: "RawContent", required: false, type: .string), 
            AWSShapeMember(label: "SilentPush", required: false, type: .boolean), 
            AWSShapeMember(label: "SmallImageIconUrl", required: false, type: .string), 
            AWSShapeMember(label: "Sound", required: false, type: .string), 
            AWSShapeMember(label: "Substitutions", required: false, type: .map), 
            AWSShapeMember(label: "Title", required: false, type: .string), 
            AWSShapeMember(label: "Url", required: false, type: .string)
        ]
        /// The action that occurs if the user taps a push notification delivered by the campaign: OPEN_APP - Your app launches, or it becomes the foreground app if it has been sent to the background. This is the default action. DEEP_LINK - Uses deep linking features in iOS and Android to open your app and display a designated user interface within the app. URL - The default mobile browser on the user's device launches and opens a web page at the URL you specify. Possible values include: OPEN_APP | DEEP_LINK | URL
        public let action: Action?
        /// The message body of the notification.
        public let body: String?
        /// Optional. Arbitrary string used to indicate multiple messages are logically the same and that ADM is allowed to drop previously enqueued messages in favor of this one.
        public let consolidationKey: String?
        /// The data payload used for a silent push. This payload is added to the notifications' data.pinpoint.jsonBody' object
        public let data: [String: String]?
        /// Optional. Number of seconds ADM should retain the message if the device is offline
        public let expiresAfter: String?
        /// The icon image name of the asset saved in your application.
        public let iconReference: String?
        /// The URL that points to an image used as the large icon to the notification content view.
        public let imageIconUrl: String?
        /// The URL that points to an image used in the push notification.
        public let imageUrl: String?
        /// Optional. Base-64-encoded MD5 checksum of the data parameter. Used to verify data integrity
        public let md5: String?
        /// The Raw JSON formatted string to be used as the payload. This value overrides the message.
        public let rawContent: String?
        /// Indicates if the message should display on the users device. Silent pushes can be used for Remote Configuration and Phone Home use cases.
        public let silentPush: Bool?
        /// The URL that points to an image used as the small icon for the notification which will be used to represent the notification in the status bar and content view
        public let smallImageIconUrl: String?
        /// Indicates a sound to play when the device receives the notification. Supports default, or the filename of a sound resource bundled in the app. Android sound files must reside in /res/raw/
        public let sound: String?
        /// Default message substitutions. Can be overridden by individual address substitutions.
        public let substitutions: [String: [String]]?
        /// The message title that displays above the message on the user's device.
        public let title: String?
        /// The URL to open in the user's mobile browser. Used if the value for Action is URL.
        public let url: String?

        public init(action: Action? = nil, body: String? = nil, consolidationKey: String? = nil, data: [String: String]? = nil, expiresAfter: String? = nil, iconReference: String? = nil, imageIconUrl: String? = nil, imageUrl: String? = nil, md5: String? = nil, rawContent: String? = nil, silentPush: Bool? = nil, smallImageIconUrl: String? = nil, sound: String? = nil, substitutions: [String: [String]]? = nil, title: String? = nil, url: String? = nil) {
            self.action = action
            self.body = body
            self.consolidationKey = consolidationKey
            self.data = data
            self.expiresAfter = expiresAfter
            self.iconReference = iconReference
            self.imageIconUrl = imageIconUrl
            self.imageUrl = imageUrl
            self.md5 = md5
            self.rawContent = rawContent
            self.silentPush = silentPush
            self.smallImageIconUrl = smallImageIconUrl
            self.sound = sound
            self.substitutions = substitutions
            self.title = title
            self.url = url
        }

        private enum CodingKeys: String, CodingKey {
            case action = "Action"
            case body = "Body"
            case consolidationKey = "ConsolidationKey"
            case data = "Data"
            case expiresAfter = "ExpiresAfter"
            case iconReference = "IconReference"
            case imageIconUrl = "ImageIconUrl"
            case imageUrl = "ImageUrl"
            case md5 = "MD5"
            case rawContent = "RawContent"
            case silentPush = "SilentPush"
            case smallImageIconUrl = "SmallImageIconUrl"
            case sound = "Sound"
            case substitutions = "Substitutions"
            case title = "Title"
            case url = "Url"
        }
    }

    public struct APNSChannelRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "BundleId", required: false, type: .string), 
            AWSShapeMember(label: "Certificate", required: false, type: .string), 
            AWSShapeMember(label: "DefaultAuthenticationMethod", required: false, type: .string), 
            AWSShapeMember(label: "Enabled", required: false, type: .boolean), 
            AWSShapeMember(label: "PrivateKey", required: false, type: .string), 
            AWSShapeMember(label: "TeamId", required: false, type: .string), 
            AWSShapeMember(label: "TokenKey", required: false, type: .string), 
            AWSShapeMember(label: "TokenKeyId", required: false, type: .string)
        ]
        /// The bundle id used for APNs Tokens.
        public let bundleId: String?
        /// The distribution certificate from Apple.
        public let certificate: String?
        /// The default authentication method used for APNs.
        public let defaultAuthenticationMethod: String?
        /// If the channel is enabled for sending messages.
        public let enabled: Bool?
        /// The certificate private key.
        public let privateKey: String?
        /// The team id used for APNs Tokens.
        public let teamId: String?
        /// The token key used for APNs Tokens.
        public let tokenKey: String?
        /// The token key used for APNs Tokens.
        public let tokenKeyId: String?

        public init(bundleId: String? = nil, certificate: String? = nil, defaultAuthenticationMethod: String? = nil, enabled: Bool? = nil, privateKey: String? = nil, teamId: String? = nil, tokenKey: String? = nil, tokenKeyId: String? = nil) {
            self.bundleId = bundleId
            self.certificate = certificate
            self.defaultAuthenticationMethod = defaultAuthenticationMethod
            self.enabled = enabled
            self.privateKey = privateKey
            self.teamId = teamId
            self.tokenKey = tokenKey
            self.tokenKeyId = tokenKeyId
        }

        private enum CodingKeys: String, CodingKey {
            case bundleId = "BundleId"
            case certificate = "Certificate"
            case defaultAuthenticationMethod = "DefaultAuthenticationMethod"
            case enabled = "Enabled"
            case privateKey = "PrivateKey"
            case teamId = "TeamId"
            case tokenKey = "TokenKey"
            case tokenKeyId = "TokenKeyId"
        }
    }

    public struct APNSChannelResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", required: false, type: .string), 
            AWSShapeMember(label: "CreationDate", required: false, type: .string), 
            AWSShapeMember(label: "DefaultAuthenticationMethod", required: false, type: .string), 
            AWSShapeMember(label: "Enabled", required: false, type: .boolean), 
            AWSShapeMember(label: "HasCredential", required: false, type: .boolean), 
            AWSShapeMember(label: "HasTokenKey", required: false, type: .boolean), 
            AWSShapeMember(label: "Id", required: false, type: .string), 
            AWSShapeMember(label: "IsArchived", required: false, type: .boolean), 
            AWSShapeMember(label: "LastModifiedBy", required: false, type: .string), 
            AWSShapeMember(label: "LastModifiedDate", required: false, type: .string), 
            AWSShapeMember(label: "Platform", required: false, type: .string), 
            AWSShapeMember(label: "Version", required: false, type: .integer)
        ]
        /// The ID of the application that the channel applies to.
        public let applicationId: String?
        /// The date and time when this channel was created.
        public let creationDate: String?
        /// The default authentication method used for APNs.
        public let defaultAuthenticationMethod: String?
        /// If the channel is enabled for sending messages.
        public let enabled: Bool?
        /// Not used. Retained for backwards compatibility.
        public let hasCredential: Bool?
        /// Indicates whether the channel is configured with a key for APNs token authentication. Provide a token key by setting the TokenKey attribute.
        public let hasTokenKey: Bool?
        /// (Deprecated) An identifier for the channel. Retained for backwards compatibility.
        public let id: String?
        /// Indicates whether or not the channel is archived.
        public let isArchived: Bool?
        /// The user who last updated this channel.
        public let lastModifiedBy: String?
        /// The date and time when this channel was last modified.
        public let lastModifiedDate: String?
        /// The platform type. For this channel, the value is always "ADM."
        public let platform: String?
        /// The channel version.
        public let version: Int32?

        public init(applicationId: String? = nil, creationDate: String? = nil, defaultAuthenticationMethod: String? = nil, enabled: Bool? = nil, hasCredential: Bool? = nil, hasTokenKey: Bool? = nil, id: String? = nil, isArchived: Bool? = nil, lastModifiedBy: String? = nil, lastModifiedDate: String? = nil, platform: String? = nil, version: Int32? = nil) {
            self.applicationId = applicationId
            self.creationDate = creationDate
            self.defaultAuthenticationMethod = defaultAuthenticationMethod
            self.enabled = enabled
            self.hasCredential = hasCredential
            self.hasTokenKey = hasTokenKey
            self.id = id
            self.isArchived = isArchived
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedDate = lastModifiedDate
            self.platform = platform
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "ApplicationId"
            case creationDate = "CreationDate"
            case defaultAuthenticationMethod = "DefaultAuthenticationMethod"
            case enabled = "Enabled"
            case hasCredential = "HasCredential"
            case hasTokenKey = "HasTokenKey"
            case id = "Id"
            case isArchived = "IsArchived"
            case lastModifiedBy = "LastModifiedBy"
            case lastModifiedDate = "LastModifiedDate"
            case platform = "Platform"
            case version = "Version"
        }
    }

    public struct APNSMessage: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Action", required: false, type: .enum), 
            AWSShapeMember(label: "Badge", required: false, type: .integer), 
            AWSShapeMember(label: "Body", required: false, type: .string), 
            AWSShapeMember(label: "Category", required: false, type: .string), 
            AWSShapeMember(label: "CollapseId", required: false, type: .string), 
            AWSShapeMember(label: "Data", required: false, type: .map), 
            AWSShapeMember(label: "MediaUrl", required: false, type: .string), 
            AWSShapeMember(label: "PreferredAuthenticationMethod", required: false, type: .string), 
            AWSShapeMember(label: "Priority", required: false, type: .string), 
            AWSShapeMember(label: "RawContent", required: false, type: .string), 
            AWSShapeMember(label: "SilentPush", required: false, type: .boolean), 
            AWSShapeMember(label: "Sound", required: false, type: .string), 
            AWSShapeMember(label: "Substitutions", required: false, type: .map), 
            AWSShapeMember(label: "ThreadId", required: false, type: .string), 
            AWSShapeMember(label: "TimeToLive", required: false, type: .integer), 
            AWSShapeMember(label: "Title", required: false, type: .string), 
            AWSShapeMember(label: "Url", required: false, type: .string)
        ]
        /// The action that occurs if the user taps a push notification delivered by the campaign: OPEN_APP - Your app launches, or it becomes the foreground app if it has been sent to the background. This is the default action. DEEP_LINK - Uses deep linking features in iOS and Android to open your app and display a designated user interface within the app. URL - The default mobile browser on the user's device launches and opens a web page at the URL you specify. Possible values include: OPEN_APP | DEEP_LINK | URL
        public let action: Action?
        /// Include this key when you want the system to modify the badge of your app icon. If this key is not included in the dictionary, the badge is not changed. To remove the badge, set the value of this key to 0.
        public let badge: Int32?
        /// The message body of the notification.
        public let body: String?
        /// Provide this key with a string value that represents the notification's type. This value corresponds to the value in the identifier property of one of your app's registered categories.
        public let category: String?
        /// An ID that, if assigned to multiple messages, causes APNs to coalesce the messages into a single push notification instead of delivering each message individually. The value must not exceed 64 bytes. Amazon Pinpoint uses this value to set the apns-collapse-id request header when it sends the message to APNs.
        public let collapseId: String?
        /// The data payload used for a silent push. This payload is added to the notifications' data.pinpoint.jsonBody' object
        public let data: [String: String]?
        /// A URL that refers to the location of an image or video that you want to display in the push notification.
        public let mediaUrl: String?
        /// The preferred authentication method, either "CERTIFICATE" or "TOKEN"
        public let preferredAuthenticationMethod: String?
        /// The message priority. Amazon Pinpoint uses this value to set the apns-priority request header when it sends the message to APNs. Accepts the following values:
        /// "5" - Low priority. Messages might be delayed, delivered in groups, and throttled.
        /// "10" - High priority. Messages are sent immediately. High priority messages must cause an alert, sound, or badge on the receiving device.
        /// The default value is "10".
        /// The equivalent values for FCM or GCM messages are "normal" and "high". Amazon Pinpoint accepts these values for APNs messages and converts them.
        /// For more information about the apns-priority parameter, see Communicating with APNs in the APNs Local and Remote Notification Programming Guide.
        public let priority: String?
        /// The Raw JSON formatted string to be used as the payload. This value overrides the message.
        public let rawContent: String?
        /// Indicates if the message should display on the users device. Silent pushes can be used for Remote Configuration and Phone Home use cases.
        public let silentPush: Bool?
        /// Include this key when you want the system to play a sound. The value of this key is the name of a sound file in your app's main bundle or in the Library/Sounds folder of your app's data container. If the sound file cannot be found, or if you specify defaultfor the value, the system plays the default alert sound.
        public let sound: String?
        /// Default message substitutions. Can be overridden by individual address substitutions.
        public let substitutions: [String: [String]]?
        /// Provide this key with a string value that represents the app-specific identifier for grouping notifications. If you provide a Notification Content app extension, you can use this value to group your notifications together.
        public let threadId: String?
        /// The length of time (in seconds) that APNs stores and attempts to deliver the message. If the value is 0, APNs does not store the message or attempt to deliver it more than once. Amazon Pinpoint uses this value to set the apns-expiration request header when it sends the message to APNs.
        public let timeToLive: Int32?
        /// The message title that displays above the message on the user's device.
        public let title: String?
        /// The URL to open in the user's mobile browser. Used if the value for Action is URL.
        public let url: String?

        public init(action: Action? = nil, badge: Int32? = nil, body: String? = nil, category: String? = nil, collapseId: String? = nil, data: [String: String]? = nil, mediaUrl: String? = nil, preferredAuthenticationMethod: String? = nil, priority: String? = nil, rawContent: String? = nil, silentPush: Bool? = nil, sound: String? = nil, substitutions: [String: [String]]? = nil, threadId: String? = nil, timeToLive: Int32? = nil, title: String? = nil, url: String? = nil) {
            self.action = action
            self.badge = badge
            self.body = body
            self.category = category
            self.collapseId = collapseId
            self.data = data
            self.mediaUrl = mediaUrl
            self.preferredAuthenticationMethod = preferredAuthenticationMethod
            self.priority = priority
            self.rawContent = rawContent
            self.silentPush = silentPush
            self.sound = sound
            self.substitutions = substitutions
            self.threadId = threadId
            self.timeToLive = timeToLive
            self.title = title
            self.url = url
        }

        private enum CodingKeys: String, CodingKey {
            case action = "Action"
            case badge = "Badge"
            case body = "Body"
            case category = "Category"
            case collapseId = "CollapseId"
            case data = "Data"
            case mediaUrl = "MediaUrl"
            case preferredAuthenticationMethod = "PreferredAuthenticationMethod"
            case priority = "Priority"
            case rawContent = "RawContent"
            case silentPush = "SilentPush"
            case sound = "Sound"
            case substitutions = "Substitutions"
            case threadId = "ThreadId"
            case timeToLive = "TimeToLive"
            case title = "Title"
            case url = "Url"
        }
    }

    public struct APNSSandboxChannelRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "BundleId", required: false, type: .string), 
            AWSShapeMember(label: "Certificate", required: false, type: .string), 
            AWSShapeMember(label: "DefaultAuthenticationMethod", required: false, type: .string), 
            AWSShapeMember(label: "Enabled", required: false, type: .boolean), 
            AWSShapeMember(label: "PrivateKey", required: false, type: .string), 
            AWSShapeMember(label: "TeamId", required: false, type: .string), 
            AWSShapeMember(label: "TokenKey", required: false, type: .string), 
            AWSShapeMember(label: "TokenKeyId", required: false, type: .string)
        ]
        /// The bundle id used for APNs Tokens.
        public let bundleId: String?
        /// The distribution certificate from Apple.
        public let certificate: String?
        /// The default authentication method used for APNs.
        public let defaultAuthenticationMethod: String?
        /// If the channel is enabled for sending messages.
        public let enabled: Bool?
        /// The certificate private key.
        public let privateKey: String?
        /// The team id used for APNs Tokens.
        public let teamId: String?
        /// The token key used for APNs Tokens.
        public let tokenKey: String?
        /// The token key used for APNs Tokens.
        public let tokenKeyId: String?

        public init(bundleId: String? = nil, certificate: String? = nil, defaultAuthenticationMethod: String? = nil, enabled: Bool? = nil, privateKey: String? = nil, teamId: String? = nil, tokenKey: String? = nil, tokenKeyId: String? = nil) {
            self.bundleId = bundleId
            self.certificate = certificate
            self.defaultAuthenticationMethod = defaultAuthenticationMethod
            self.enabled = enabled
            self.privateKey = privateKey
            self.teamId = teamId
            self.tokenKey = tokenKey
            self.tokenKeyId = tokenKeyId
        }

        private enum CodingKeys: String, CodingKey {
            case bundleId = "BundleId"
            case certificate = "Certificate"
            case defaultAuthenticationMethod = "DefaultAuthenticationMethod"
            case enabled = "Enabled"
            case privateKey = "PrivateKey"
            case teamId = "TeamId"
            case tokenKey = "TokenKey"
            case tokenKeyId = "TokenKeyId"
        }
    }

    public struct APNSSandboxChannelResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", required: false, type: .string), 
            AWSShapeMember(label: "CreationDate", required: false, type: .string), 
            AWSShapeMember(label: "DefaultAuthenticationMethod", required: false, type: .string), 
            AWSShapeMember(label: "Enabled", required: false, type: .boolean), 
            AWSShapeMember(label: "HasCredential", required: false, type: .boolean), 
            AWSShapeMember(label: "HasTokenKey", required: false, type: .boolean), 
            AWSShapeMember(label: "Id", required: false, type: .string), 
            AWSShapeMember(label: "IsArchived", required: false, type: .boolean), 
            AWSShapeMember(label: "LastModifiedBy", required: false, type: .string), 
            AWSShapeMember(label: "LastModifiedDate", required: false, type: .string), 
            AWSShapeMember(label: "Platform", required: false, type: .string), 
            AWSShapeMember(label: "Version", required: false, type: .integer)
        ]
        /// The ID of the application to which the channel applies.
        public let applicationId: String?
        /// When was this segment created
        public let creationDate: String?
        /// The default authentication method used for APNs.
        public let defaultAuthenticationMethod: String?
        /// If the channel is enabled for sending messages.
        public let enabled: Bool?
        /// Not used. Retained for backwards compatibility.
        public let hasCredential: Bool?
        /// Indicates whether the channel is configured with a key for APNs token authentication. Provide a token key by setting the TokenKey attribute.
        public let hasTokenKey: Bool?
        /// Channel ID. Not used, only for backwards compatibility.
        public let id: String?
        /// Is this channel archived
        public let isArchived: Bool?
        /// Who last updated this entry
        public let lastModifiedBy: String?
        /// Last date this was updated
        public let lastModifiedDate: String?
        /// The platform type. Will be APNS_SANDBOX.
        public let platform: String?
        /// Version of channel
        public let version: Int32?

        public init(applicationId: String? = nil, creationDate: String? = nil, defaultAuthenticationMethod: String? = nil, enabled: Bool? = nil, hasCredential: Bool? = nil, hasTokenKey: Bool? = nil, id: String? = nil, isArchived: Bool? = nil, lastModifiedBy: String? = nil, lastModifiedDate: String? = nil, platform: String? = nil, version: Int32? = nil) {
            self.applicationId = applicationId
            self.creationDate = creationDate
            self.defaultAuthenticationMethod = defaultAuthenticationMethod
            self.enabled = enabled
            self.hasCredential = hasCredential
            self.hasTokenKey = hasTokenKey
            self.id = id
            self.isArchived = isArchived
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedDate = lastModifiedDate
            self.platform = platform
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "ApplicationId"
            case creationDate = "CreationDate"
            case defaultAuthenticationMethod = "DefaultAuthenticationMethod"
            case enabled = "Enabled"
            case hasCredential = "HasCredential"
            case hasTokenKey = "HasTokenKey"
            case id = "Id"
            case isArchived = "IsArchived"
            case lastModifiedBy = "LastModifiedBy"
            case lastModifiedDate = "LastModifiedDate"
            case platform = "Platform"
            case version = "Version"
        }
    }

    public struct APNSVoipChannelRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "BundleId", required: false, type: .string), 
            AWSShapeMember(label: "Certificate", required: false, type: .string), 
            AWSShapeMember(label: "DefaultAuthenticationMethod", required: false, type: .string), 
            AWSShapeMember(label: "Enabled", required: false, type: .boolean), 
            AWSShapeMember(label: "PrivateKey", required: false, type: .string), 
            AWSShapeMember(label: "TeamId", required: false, type: .string), 
            AWSShapeMember(label: "TokenKey", required: false, type: .string), 
            AWSShapeMember(label: "TokenKeyId", required: false, type: .string)
        ]
        /// The bundle id used for APNs Tokens.
        public let bundleId: String?
        /// The distribution certificate from Apple.
        public let certificate: String?
        /// The default authentication method used for APNs.
        public let defaultAuthenticationMethod: String?
        /// If the channel is enabled for sending messages.
        public let enabled: Bool?
        /// The certificate private key.
        public let privateKey: String?
        /// The team id used for APNs Tokens.
        public let teamId: String?
        /// The token key used for APNs Tokens.
        public let tokenKey: String?
        /// The token key used for APNs Tokens.
        public let tokenKeyId: String?

        public init(bundleId: String? = nil, certificate: String? = nil, defaultAuthenticationMethod: String? = nil, enabled: Bool? = nil, privateKey: String? = nil, teamId: String? = nil, tokenKey: String? = nil, tokenKeyId: String? = nil) {
            self.bundleId = bundleId
            self.certificate = certificate
            self.defaultAuthenticationMethod = defaultAuthenticationMethod
            self.enabled = enabled
            self.privateKey = privateKey
            self.teamId = teamId
            self.tokenKey = tokenKey
            self.tokenKeyId = tokenKeyId
        }

        private enum CodingKeys: String, CodingKey {
            case bundleId = "BundleId"
            case certificate = "Certificate"
            case defaultAuthenticationMethod = "DefaultAuthenticationMethod"
            case enabled = "Enabled"
            case privateKey = "PrivateKey"
            case teamId = "TeamId"
            case tokenKey = "TokenKey"
            case tokenKeyId = "TokenKeyId"
        }
    }

    public struct APNSVoipChannelResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", required: false, type: .string), 
            AWSShapeMember(label: "CreationDate", required: false, type: .string), 
            AWSShapeMember(label: "DefaultAuthenticationMethod", required: false, type: .string), 
            AWSShapeMember(label: "Enabled", required: false, type: .boolean), 
            AWSShapeMember(label: "HasCredential", required: false, type: .boolean), 
            AWSShapeMember(label: "HasTokenKey", required: false, type: .boolean), 
            AWSShapeMember(label: "Id", required: false, type: .string), 
            AWSShapeMember(label: "IsArchived", required: false, type: .boolean), 
            AWSShapeMember(label: "LastModifiedBy", required: false, type: .string), 
            AWSShapeMember(label: "LastModifiedDate", required: false, type: .string), 
            AWSShapeMember(label: "Platform", required: false, type: .string), 
            AWSShapeMember(label: "Version", required: false, type: .integer)
        ]
        /// Application id
        public let applicationId: String?
        /// When was this segment created
        public let creationDate: String?
        /// The default authentication method used for APNs.
        public let defaultAuthenticationMethod: String?
        /// If the channel is enabled for sending messages.
        public let enabled: Bool?
        /// Not used. Retained for backwards compatibility.
        public let hasCredential: Bool?
        /// If the channel is registered with a token key for authentication.
        public let hasTokenKey: Bool?
        /// Channel ID. Not used, only for backwards compatibility.
        public let id: String?
        /// Is this channel archived
        public let isArchived: Bool?
        /// Who made the last change
        public let lastModifiedBy: String?
        /// Last date this was updated
        public let lastModifiedDate: String?
        /// The platform type. Will be APNS.
        public let platform: String?
        /// Version of channel
        public let version: Int32?

        public init(applicationId: String? = nil, creationDate: String? = nil, defaultAuthenticationMethod: String? = nil, enabled: Bool? = nil, hasCredential: Bool? = nil, hasTokenKey: Bool? = nil, id: String? = nil, isArchived: Bool? = nil, lastModifiedBy: String? = nil, lastModifiedDate: String? = nil, platform: String? = nil, version: Int32? = nil) {
            self.applicationId = applicationId
            self.creationDate = creationDate
            self.defaultAuthenticationMethod = defaultAuthenticationMethod
            self.enabled = enabled
            self.hasCredential = hasCredential
            self.hasTokenKey = hasTokenKey
            self.id = id
            self.isArchived = isArchived
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedDate = lastModifiedDate
            self.platform = platform
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "ApplicationId"
            case creationDate = "CreationDate"
            case defaultAuthenticationMethod = "DefaultAuthenticationMethod"
            case enabled = "Enabled"
            case hasCredential = "HasCredential"
            case hasTokenKey = "HasTokenKey"
            case id = "Id"
            case isArchived = "IsArchived"
            case lastModifiedBy = "LastModifiedBy"
            case lastModifiedDate = "LastModifiedDate"
            case platform = "Platform"
            case version = "Version"
        }
    }

    public struct APNSVoipSandboxChannelRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "BundleId", required: false, type: .string), 
            AWSShapeMember(label: "Certificate", required: false, type: .string), 
            AWSShapeMember(label: "DefaultAuthenticationMethod", required: false, type: .string), 
            AWSShapeMember(label: "Enabled", required: false, type: .boolean), 
            AWSShapeMember(label: "PrivateKey", required: false, type: .string), 
            AWSShapeMember(label: "TeamId", required: false, type: .string), 
            AWSShapeMember(label: "TokenKey", required: false, type: .string), 
            AWSShapeMember(label: "TokenKeyId", required: false, type: .string)
        ]
        /// The bundle id used for APNs Tokens.
        public let bundleId: String?
        /// The distribution certificate from Apple.
        public let certificate: String?
        /// The default authentication method used for APNs.
        public let defaultAuthenticationMethod: String?
        /// If the channel is enabled for sending messages.
        public let enabled: Bool?
        /// The certificate private key.
        public let privateKey: String?
        /// The team id used for APNs Tokens.
        public let teamId: String?
        /// The token key used for APNs Tokens.
        public let tokenKey: String?
        /// The token key used for APNs Tokens.
        public let tokenKeyId: String?

        public init(bundleId: String? = nil, certificate: String? = nil, defaultAuthenticationMethod: String? = nil, enabled: Bool? = nil, privateKey: String? = nil, teamId: String? = nil, tokenKey: String? = nil, tokenKeyId: String? = nil) {
            self.bundleId = bundleId
            self.certificate = certificate
            self.defaultAuthenticationMethod = defaultAuthenticationMethod
            self.enabled = enabled
            self.privateKey = privateKey
            self.teamId = teamId
            self.tokenKey = tokenKey
            self.tokenKeyId = tokenKeyId
        }

        private enum CodingKeys: String, CodingKey {
            case bundleId = "BundleId"
            case certificate = "Certificate"
            case defaultAuthenticationMethod = "DefaultAuthenticationMethod"
            case enabled = "Enabled"
            case privateKey = "PrivateKey"
            case teamId = "TeamId"
            case tokenKey = "TokenKey"
            case tokenKeyId = "TokenKeyId"
        }
    }

    public struct APNSVoipSandboxChannelResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", required: false, type: .string), 
            AWSShapeMember(label: "CreationDate", required: false, type: .string), 
            AWSShapeMember(label: "DefaultAuthenticationMethod", required: false, type: .string), 
            AWSShapeMember(label: "Enabled", required: false, type: .boolean), 
            AWSShapeMember(label: "HasCredential", required: false, type: .boolean), 
            AWSShapeMember(label: "HasTokenKey", required: false, type: .boolean), 
            AWSShapeMember(label: "Id", required: false, type: .string), 
            AWSShapeMember(label: "IsArchived", required: false, type: .boolean), 
            AWSShapeMember(label: "LastModifiedBy", required: false, type: .string), 
            AWSShapeMember(label: "LastModifiedDate", required: false, type: .string), 
            AWSShapeMember(label: "Platform", required: false, type: .string), 
            AWSShapeMember(label: "Version", required: false, type: .integer)
        ]
        /// Application id
        public let applicationId: String?
        /// When was this segment created
        public let creationDate: String?
        /// The default authentication method used for APNs.
        public let defaultAuthenticationMethod: String?
        /// If the channel is enabled for sending messages.
        public let enabled: Bool?
        /// Not used. Retained for backwards compatibility.
        public let hasCredential: Bool?
        /// If the channel is registered with a token key for authentication.
        public let hasTokenKey: Bool?
        /// Channel ID. Not used, only for backwards compatibility.
        public let id: String?
        /// Is this channel archived
        public let isArchived: Bool?
        /// Who made the last change
        public let lastModifiedBy: String?
        /// Last date this was updated
        public let lastModifiedDate: String?
        /// The platform type. Will be APNS.
        public let platform: String?
        /// Version of channel
        public let version: Int32?

        public init(applicationId: String? = nil, creationDate: String? = nil, defaultAuthenticationMethod: String? = nil, enabled: Bool? = nil, hasCredential: Bool? = nil, hasTokenKey: Bool? = nil, id: String? = nil, isArchived: Bool? = nil, lastModifiedBy: String? = nil, lastModifiedDate: String? = nil, platform: String? = nil, version: Int32? = nil) {
            self.applicationId = applicationId
            self.creationDate = creationDate
            self.defaultAuthenticationMethod = defaultAuthenticationMethod
            self.enabled = enabled
            self.hasCredential = hasCredential
            self.hasTokenKey = hasTokenKey
            self.id = id
            self.isArchived = isArchived
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedDate = lastModifiedDate
            self.platform = platform
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "ApplicationId"
            case creationDate = "CreationDate"
            case defaultAuthenticationMethod = "DefaultAuthenticationMethod"
            case enabled = "Enabled"
            case hasCredential = "HasCredential"
            case hasTokenKey = "HasTokenKey"
            case id = "Id"
            case isArchived = "IsArchived"
            case lastModifiedBy = "LastModifiedBy"
            case lastModifiedDate = "LastModifiedDate"
            case platform = "Platform"
            case version = "Version"
        }
    }

    public enum Action: String, CustomStringConvertible, Codable {
        case openApp = "OPEN_APP"
        case deepLink = "DEEP_LINK"
        case url = "URL"
        public var description: String { return self.rawValue }
    }

    public struct ActivitiesResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Item", required: false, type: .list), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]
        /// List of campaign activities
        public let item: [ActivityResponse]?
        /// The string that you use in a subsequent request to get the next page of results in a paginated response.
        public let nextToken: String?

        public init(item: [ActivityResponse]? = nil, nextToken: String? = nil) {
            self.item = item
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case item = "Item"
            case nextToken = "NextToken"
        }
    }

    public struct ActivityResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", required: false, type: .string), 
            AWSShapeMember(label: "CampaignId", required: false, type: .string), 
            AWSShapeMember(label: "End", required: false, type: .string), 
            AWSShapeMember(label: "Id", required: false, type: .string), 
            AWSShapeMember(label: "Result", required: false, type: .string), 
            AWSShapeMember(label: "ScheduledStart", required: false, type: .string), 
            AWSShapeMember(label: "Start", required: false, type: .string), 
            AWSShapeMember(label: "State", required: false, type: .string), 
            AWSShapeMember(label: "SuccessfulEndpointCount", required: false, type: .integer), 
            AWSShapeMember(label: "TimezonesCompletedCount", required: false, type: .integer), 
            AWSShapeMember(label: "TimezonesTotalCount", required: false, type: .integer), 
            AWSShapeMember(label: "TotalEndpointCount", required: false, type: .integer), 
            AWSShapeMember(label: "TreatmentId", required: false, type: .string)
        ]
        /// The ID of the application to which the campaign applies.
        public let applicationId: String?
        /// The ID of the campaign to which the activity applies.
        public let campaignId: String?
        /// The actual time the activity was marked CANCELLED or COMPLETED. Provided in ISO 8601 format.
        public let end: String?
        /// The unique activity ID.
        public let id: String?
        /// Indicates whether the activity succeeded.
        /// Valid values: SUCCESS, FAIL
        public let result: String?
        /// The scheduled start time for the activity in ISO 8601 format.
        public let scheduledStart: String?
        /// The actual start time of the activity in ISO 8601 format.
        public let start: String?
        /// The state of the activity.
        /// Valid values: PENDING, INITIALIZING, RUNNING, PAUSED, CANCELLED, COMPLETED
        public let state: String?
        /// The total number of endpoints to which the campaign successfully delivered messages.
        public let successfulEndpointCount: Int32?
        /// The total number of timezones completed.
        public let timezonesCompletedCount: Int32?
        /// The total number of unique timezones present in the segment.
        public let timezonesTotalCount: Int32?
        /// The total number of endpoints to which the campaign attempts to deliver messages.
        public let totalEndpointCount: Int32?
        /// The ID of a variation of the campaign used for A/B testing.
        public let treatmentId: String?

        public init(applicationId: String? = nil, campaignId: String? = nil, end: String? = nil, id: String? = nil, result: String? = nil, scheduledStart: String? = nil, start: String? = nil, state: String? = nil, successfulEndpointCount: Int32? = nil, timezonesCompletedCount: Int32? = nil, timezonesTotalCount: Int32? = nil, totalEndpointCount: Int32? = nil, treatmentId: String? = nil) {
            self.applicationId = applicationId
            self.campaignId = campaignId
            self.end = end
            self.id = id
            self.result = result
            self.scheduledStart = scheduledStart
            self.start = start
            self.state = state
            self.successfulEndpointCount = successfulEndpointCount
            self.timezonesCompletedCount = timezonesCompletedCount
            self.timezonesTotalCount = timezonesTotalCount
            self.totalEndpointCount = totalEndpointCount
            self.treatmentId = treatmentId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "ApplicationId"
            case campaignId = "CampaignId"
            case end = "End"
            case id = "Id"
            case result = "Result"
            case scheduledStart = "ScheduledStart"
            case start = "Start"
            case state = "State"
            case successfulEndpointCount = "SuccessfulEndpointCount"
            case timezonesCompletedCount = "TimezonesCompletedCount"
            case timezonesTotalCount = "TimezonesTotalCount"
            case totalEndpointCount = "TotalEndpointCount"
            case treatmentId = "TreatmentId"
        }
    }

    public struct AddressConfiguration: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "BodyOverride", required: false, type: .string), 
            AWSShapeMember(label: "ChannelType", required: false, type: .enum), 
            AWSShapeMember(label: "Context", required: false, type: .map), 
            AWSShapeMember(label: "RawContent", required: false, type: .string), 
            AWSShapeMember(label: "Substitutions", required: false, type: .map), 
            AWSShapeMember(label: "TitleOverride", required: false, type: .string)
        ]
        /// Body override. If specified will override default body.
        public let bodyOverride: String?
        /// The channel type.
        /// Valid values: GCM | APNS | APNS_SANDBOX | APNS_VOIP | APNS_VOIP_SANDBOX | ADM | SMS | EMAIL | BAIDU
        public let channelType: ChannelType?
        /// A map of custom attributes to attributes to be attached to the message for this address. This payload is added to the push notification's 'data.pinpoint' object or added to the email/sms delivery receipt event attributes.
        public let context: [String: String]?
        /// The Raw JSON formatted string to be used as the payload. This value overrides the message.
        public let rawContent: String?
        /// A map of substitution values for the message to be merged with the DefaultMessage's substitutions. Substitutions on this map take precedence over the all other substitutions.
        public let substitutions: [String: [String]]?
        /// Title override. If specified will override default title if applicable.
        public let titleOverride: String?

        public init(bodyOverride: String? = nil, channelType: ChannelType? = nil, context: [String: String]? = nil, rawContent: String? = nil, substitutions: [String: [String]]? = nil, titleOverride: String? = nil) {
            self.bodyOverride = bodyOverride
            self.channelType = channelType
            self.context = context
            self.rawContent = rawContent
            self.substitutions = substitutions
            self.titleOverride = titleOverride
        }

        private enum CodingKeys: String, CodingKey {
            case bodyOverride = "BodyOverride"
            case channelType = "ChannelType"
            case context = "Context"
            case rawContent = "RawContent"
            case substitutions = "Substitutions"
            case titleOverride = "TitleOverride"
        }
    }

    public struct ApplicationResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Arn", required: false, type: .string), 
            AWSShapeMember(label: "Id", required: false, type: .string), 
            AWSShapeMember(label: "Name", required: false, type: .string), 
            AWSShapeMember(label: "tags", location: .body(locationName: "tags"), required: false, type: .map)
        ]
        /// The arn for the application.
        public let arn: String?
        /// The unique application ID.
        public let id: String?
        /// The display name of the application.
        public let name: String?
        /// The Tags for the application.
        public let tags: [String: String]?

        public init(arn: String? = nil, id: String? = nil, name: String? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.id = id
            self.name = name
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case id = "Id"
            case name = "Name"
            case tags = "tags"
        }
    }

    public struct ApplicationSettingsResource: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", required: false, type: .string), 
            AWSShapeMember(label: "CampaignHook", required: false, type: .structure), 
            AWSShapeMember(label: "LastModifiedDate", required: false, type: .string), 
            AWSShapeMember(label: "Limits", required: false, type: .structure), 
            AWSShapeMember(label: "QuietTime", required: false, type: .structure)
        ]
        /// The unique ID for the application.
        public let applicationId: String?
        /// Default campaign hook.
        public let campaignHook: CampaignHook?
        /// The date that the settings were last updated in ISO 8601 format.
        public let lastModifiedDate: String?
        /// The default campaign limits for the app. These limits apply to each campaign for the app, unless the campaign overrides the default with limits of its own.
        public let limits: CampaignLimits?
        /// The default quiet time for the app. Campaigns in the app don't send messages to endpoints during the quiet time.
        /// Note: Make sure that your endpoints include the Demographics.Timezone attribute if you plan to enable a quiet time for your app. If your endpoints don't include this attribute, they'll receive the messages that you send them, even if quiet time is enabled.
        /// When you set up an app to use quiet time, campaigns in that app don't send messages during the time range you specified, as long as all of the following are true:
        /// - The endpoint includes a valid Demographic.Timezone attribute.
        /// - The current time in the endpoint's time zone is later than or equal to the time specified in the QuietTime.Start attribute for the app (or campaign, if applicable).
        /// - The current time in the endpoint's time zone is earlier than or equal to the time specified in the QuietTime.End attribute for the app (or campaign, if applicable).
        /// Individual campaigns within the app can have their own quiet time settings, which override the quiet time settings at the app level.
        public let quietTime: QuietTime?

        public init(applicationId: String? = nil, campaignHook: CampaignHook? = nil, lastModifiedDate: String? = nil, limits: CampaignLimits? = nil, quietTime: QuietTime? = nil) {
            self.applicationId = applicationId
            self.campaignHook = campaignHook
            self.lastModifiedDate = lastModifiedDate
            self.limits = limits
            self.quietTime = quietTime
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "ApplicationId"
            case campaignHook = "CampaignHook"
            case lastModifiedDate = "LastModifiedDate"
            case limits = "Limits"
            case quietTime = "QuietTime"
        }
    }

    public struct ApplicationsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Item", required: false, type: .list), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]
        /// List of applications returned in this page.
        public let item: [ApplicationResponse]?
        /// The string that you use in a subsequent request to get the next page of results in a paginated response.
        public let nextToken: String?

        public init(item: [ApplicationResponse]? = nil, nextToken: String? = nil) {
            self.item = item
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case item = "Item"
            case nextToken = "NextToken"
        }
    }

    public struct AttributeDimension: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AttributeType", required: false, type: .enum), 
            AWSShapeMember(label: "Values", required: false, type: .list)
        ]
        /// The type of dimension:
        /// INCLUSIVE - Endpoints that match the criteria are included in the segment.
        /// EXCLUSIVE - Endpoints that match the criteria are excluded from the segment.
        public let attributeType: AttributeType?
        /// The criteria values for the segment dimension. Endpoints with matching attribute values are included or excluded from the segment, depending on the setting for Type.
        public let values: [String]?

        public init(attributeType: AttributeType? = nil, values: [String]? = nil) {
            self.attributeType = attributeType
            self.values = values
        }

        private enum CodingKeys: String, CodingKey {
            case attributeType = "AttributeType"
            case values = "Values"
        }
    }

    public enum AttributeType: String, CustomStringConvertible, Codable {
        case inclusive = "INCLUSIVE"
        case exclusive = "EXCLUSIVE"
        public var description: String { return self.rawValue }
    }

    public struct AttributesResource: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", required: false, type: .string), 
            AWSShapeMember(label: "AttributeType", required: false, type: .string), 
            AWSShapeMember(label: "Attributes", required: false, type: .list)
        ]
        /// The unique ID for the application.
        public let applicationId: String?
        /// The attribute type for the application.
        public let attributeType: String?
        /// The attributes for the application.
        public let attributes: [String]?

        public init(applicationId: String? = nil, attributeType: String? = nil, attributes: [String]? = nil) {
            self.applicationId = applicationId
            self.attributeType = attributeType
            self.attributes = attributes
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "ApplicationId"
            case attributeType = "AttributeType"
            case attributes = "Attributes"
        }
    }

    public struct BaiduChannelRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApiKey", required: false, type: .string), 
            AWSShapeMember(label: "Enabled", required: false, type: .boolean), 
            AWSShapeMember(label: "SecretKey", required: false, type: .string)
        ]
        /// Platform credential API key from Baidu.
        public let apiKey: String?
        /// If the channel is enabled for sending messages.
        public let enabled: Bool?
        /// Platform credential Secret key from Baidu.
        public let secretKey: String?

        public init(apiKey: String? = nil, enabled: Bool? = nil, secretKey: String? = nil) {
            self.apiKey = apiKey
            self.enabled = enabled
            self.secretKey = secretKey
        }

        private enum CodingKeys: String, CodingKey {
            case apiKey = "ApiKey"
            case enabled = "Enabled"
            case secretKey = "SecretKey"
        }
    }

    public struct BaiduChannelResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", required: false, type: .string), 
            AWSShapeMember(label: "CreationDate", required: false, type: .string), 
            AWSShapeMember(label: "Credential", required: false, type: .string), 
            AWSShapeMember(label: "Enabled", required: false, type: .boolean), 
            AWSShapeMember(label: "HasCredential", required: false, type: .boolean), 
            AWSShapeMember(label: "Id", required: false, type: .string), 
            AWSShapeMember(label: "IsArchived", required: false, type: .boolean), 
            AWSShapeMember(label: "LastModifiedBy", required: false, type: .string), 
            AWSShapeMember(label: "LastModifiedDate", required: false, type: .string), 
            AWSShapeMember(label: "Platform", required: false, type: .string), 
            AWSShapeMember(label: "Version", required: false, type: .integer)
        ]
        /// Application id
        public let applicationId: String?
        /// When was this segment created
        public let creationDate: String?
        /// The Baidu API key from Baidu.
        public let credential: String?
        /// If the channel is enabled for sending messages.
        public let enabled: Bool?
        /// Not used. Retained for backwards compatibility.
        public let hasCredential: Bool?
        /// Channel ID. Not used, only for backwards compatibility.
        public let id: String?
        /// Is this channel archived
        public let isArchived: Bool?
        /// Who made the last change
        public let lastModifiedBy: String?
        /// Last date this was updated
        public let lastModifiedDate: String?
        /// The platform type. Will be BAIDU
        public let platform: String?
        /// Version of channel
        public let version: Int32?

        public init(applicationId: String? = nil, creationDate: String? = nil, credential: String? = nil, enabled: Bool? = nil, hasCredential: Bool? = nil, id: String? = nil, isArchived: Bool? = nil, lastModifiedBy: String? = nil, lastModifiedDate: String? = nil, platform: String? = nil, version: Int32? = nil) {
            self.applicationId = applicationId
            self.creationDate = creationDate
            self.credential = credential
            self.enabled = enabled
            self.hasCredential = hasCredential
            self.id = id
            self.isArchived = isArchived
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedDate = lastModifiedDate
            self.platform = platform
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "ApplicationId"
            case creationDate = "CreationDate"
            case credential = "Credential"
            case enabled = "Enabled"
            case hasCredential = "HasCredential"
            case id = "Id"
            case isArchived = "IsArchived"
            case lastModifiedBy = "LastModifiedBy"
            case lastModifiedDate = "LastModifiedDate"
            case platform = "Platform"
            case version = "Version"
        }
    }

    public struct BaiduMessage: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Action", required: false, type: .enum), 
            AWSShapeMember(label: "Body", required: false, type: .string), 
            AWSShapeMember(label: "Data", required: false, type: .map), 
            AWSShapeMember(label: "IconReference", required: false, type: .string), 
            AWSShapeMember(label: "ImageIconUrl", required: false, type: .string), 
            AWSShapeMember(label: "ImageUrl", required: false, type: .string), 
            AWSShapeMember(label: "RawContent", required: false, type: .string), 
            AWSShapeMember(label: "SilentPush", required: false, type: .boolean), 
            AWSShapeMember(label: "SmallImageIconUrl", required: false, type: .string), 
            AWSShapeMember(label: "Sound", required: false, type: .string), 
            AWSShapeMember(label: "Substitutions", required: false, type: .map), 
            AWSShapeMember(label: "TimeToLive", required: false, type: .integer), 
            AWSShapeMember(label: "Title", required: false, type: .string), 
            AWSShapeMember(label: "Url", required: false, type: .string)
        ]
        /// The action that occurs if the user taps a push notification delivered by the campaign: OPEN_APP - Your app launches, or it becomes the foreground app if it has been sent to the background. This is the default action. DEEP_LINK - Uses deep linking features in iOS and Android to open your app and display a designated user interface within the app. URL - The default mobile browser on the user's device launches and opens a web page at the URL you specify. Possible values include: OPEN_APP | DEEP_LINK | URL
        public let action: Action?
        /// The message body of the notification.
        public let body: String?
        /// The data payload used for a silent push. This payload is added to the notifications' data.pinpoint.jsonBody' object
        public let data: [String: String]?
        /// The icon image name of the asset saved in your application.
        public let iconReference: String?
        /// The URL that points to an image used as the large icon to the notification content view.
        public let imageIconUrl: String?
        /// The URL that points to an image used in the push notification.
        public let imageUrl: String?
        /// The Raw JSON formatted string to be used as the payload. This value overrides the message.
        public let rawContent: String?
        /// Indicates if the message should display on the users device. Silent pushes can be used for Remote Configuration and Phone Home use cases.
        public let silentPush: Bool?
        /// The URL that points to an image used as the small icon for the notification which will be used to represent the notification in the status bar and content view
        public let smallImageIconUrl: String?
        /// Indicates a sound to play when the device receives the notification. Supports default, or the filename of a sound resource bundled in the app. Android sound files must reside in /res/raw/
        public let sound: String?
        /// Default message substitutions. Can be overridden by individual address substitutions.
        public let substitutions: [String: [String]]?
        /// This parameter specifies how long (in seconds) the message should be kept in Baidu storage if the device is offline. The and the default value and the maximum time to live supported is 7 days (604800 seconds)
        public let timeToLive: Int32?
        /// The message title that displays above the message on the user's device.
        public let title: String?
        /// The URL to open in the user's mobile browser. Used if the value for Action is URL.
        public let url: String?

        public init(action: Action? = nil, body: String? = nil, data: [String: String]? = nil, iconReference: String? = nil, imageIconUrl: String? = nil, imageUrl: String? = nil, rawContent: String? = nil, silentPush: Bool? = nil, smallImageIconUrl: String? = nil, sound: String? = nil, substitutions: [String: [String]]? = nil, timeToLive: Int32? = nil, title: String? = nil, url: String? = nil) {
            self.action = action
            self.body = body
            self.data = data
            self.iconReference = iconReference
            self.imageIconUrl = imageIconUrl
            self.imageUrl = imageUrl
            self.rawContent = rawContent
            self.silentPush = silentPush
            self.smallImageIconUrl = smallImageIconUrl
            self.sound = sound
            self.substitutions = substitutions
            self.timeToLive = timeToLive
            self.title = title
            self.url = url
        }

        private enum CodingKeys: String, CodingKey {
            case action = "Action"
            case body = "Body"
            case data = "Data"
            case iconReference = "IconReference"
            case imageIconUrl = "ImageIconUrl"
            case imageUrl = "ImageUrl"
            case rawContent = "RawContent"
            case silentPush = "SilentPush"
            case smallImageIconUrl = "SmallImageIconUrl"
            case sound = "Sound"
            case substitutions = "Substitutions"
            case timeToLive = "TimeToLive"
            case title = "Title"
            case url = "Url"
        }
    }

    public struct CampaignEmailMessage: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Body", required: false, type: .string), 
            AWSShapeMember(label: "FromAddress", required: false, type: .string), 
            AWSShapeMember(label: "HtmlBody", required: false, type: .string), 
            AWSShapeMember(label: "Title", required: false, type: .string)
        ]
        /// The email text body.
        public let body: String?
        /// The email address used to send the email from. Defaults to use FromAddress specified in the Email Channel.
        public let fromAddress: String?
        /// The email html body.
        public let htmlBody: String?
        /// The email title (Or subject).
        public let title: String?

        public init(body: String? = nil, fromAddress: String? = nil, htmlBody: String? = nil, title: String? = nil) {
            self.body = body
            self.fromAddress = fromAddress
            self.htmlBody = htmlBody
            self.title = title
        }

        private enum CodingKeys: String, CodingKey {
            case body = "Body"
            case fromAddress = "FromAddress"
            case htmlBody = "HtmlBody"
            case title = "Title"
        }
    }

    public struct CampaignEventFilter: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Dimensions", required: false, type: .structure), 
            AWSShapeMember(label: "FilterType", required: false, type: .enum)
        ]
        /// An object that defines the dimensions for the event filter.
        public let dimensions: EventDimensions?
        /// The type of event that causes the campaign to be sent. Possible values:
        /// SYSTEM - Send the campaign when a system event occurs. See the System resource for more information.
        /// ENDPOINT - Send the campaign when an endpoint event occurs. See the Event resource for more information.
        public let filterType: FilterType?

        public init(dimensions: EventDimensions? = nil, filterType: FilterType? = nil) {
            self.dimensions = dimensions
            self.filterType = filterType
        }

        private enum CodingKeys: String, CodingKey {
            case dimensions = "Dimensions"
            case filterType = "FilterType"
        }
    }

    public struct CampaignHook: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "LambdaFunctionName", required: false, type: .string), 
            AWSShapeMember(label: "Mode", required: false, type: .enum), 
            AWSShapeMember(label: "WebUrl", required: false, type: .string)
        ]
        /// Lambda function name or arn to be called for delivery
        public let lambdaFunctionName: String?
        /// What mode Lambda should be invoked in.
        public let mode: Mode?
        /// Web URL to call for hook. If the URL has authentication specified it will be added as authentication to the request
        public let webUrl: String?

        public init(lambdaFunctionName: String? = nil, mode: Mode? = nil, webUrl: String? = nil) {
            self.lambdaFunctionName = lambdaFunctionName
            self.mode = mode
            self.webUrl = webUrl
        }

        private enum CodingKeys: String, CodingKey {
            case lambdaFunctionName = "LambdaFunctionName"
            case mode = "Mode"
            case webUrl = "WebUrl"
        }
    }

    public struct CampaignLimits: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Daily", required: false, type: .integer), 
            AWSShapeMember(label: "MaximumDuration", required: false, type: .integer), 
            AWSShapeMember(label: "MessagesPerSecond", required: false, type: .integer), 
            AWSShapeMember(label: "Total", required: false, type: .integer)
        ]
        /// The maximum number of messages that each campaign can send to a single endpoint in a 24-hour period.
        public let daily: Int32?
        /// The length of time (in seconds) that the campaign can run before it ends and message deliveries stop. This duration begins at the scheduled start time for the campaign. The minimum value is 60.
        public let maximumDuration: Int32?
        /// The number of messages that the campaign can send per second. The minimum value is 50, and the maximum is 20000.
        public let messagesPerSecond: Int32?
        /// The maximum number of messages that an individual campaign can send to a single endpoint over the course of the campaign.
        public let total: Int32?

        public init(daily: Int32? = nil, maximumDuration: Int32? = nil, messagesPerSecond: Int32? = nil, total: Int32? = nil) {
            self.daily = daily
            self.maximumDuration = maximumDuration
            self.messagesPerSecond = messagesPerSecond
            self.total = total
        }

        private enum CodingKeys: String, CodingKey {
            case daily = "Daily"
            case maximumDuration = "MaximumDuration"
            case messagesPerSecond = "MessagesPerSecond"
            case total = "Total"
        }
    }

    public struct CampaignResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AdditionalTreatments", required: false, type: .list), 
            AWSShapeMember(label: "ApplicationId", required: false, type: .string), 
            AWSShapeMember(label: "Arn", required: false, type: .string), 
            AWSShapeMember(label: "CreationDate", required: false, type: .string), 
            AWSShapeMember(label: "DefaultState", required: false, type: .structure), 
            AWSShapeMember(label: "Description", required: false, type: .string), 
            AWSShapeMember(label: "HoldoutPercent", required: false, type: .integer), 
            AWSShapeMember(label: "Hook", required: false, type: .structure), 
            AWSShapeMember(label: "Id", required: false, type: .string), 
            AWSShapeMember(label: "IsPaused", required: false, type: .boolean), 
            AWSShapeMember(label: "LastModifiedDate", required: false, type: .string), 
            AWSShapeMember(label: "Limits", required: false, type: .structure), 
            AWSShapeMember(label: "MessageConfiguration", required: false, type: .structure), 
            AWSShapeMember(label: "Name", required: false, type: .string), 
            AWSShapeMember(label: "Schedule", required: false, type: .structure), 
            AWSShapeMember(label: "SegmentId", required: false, type: .string), 
            AWSShapeMember(label: "SegmentVersion", required: false, type: .integer), 
            AWSShapeMember(label: "State", required: false, type: .structure), 
            AWSShapeMember(label: "TreatmentDescription", required: false, type: .string), 
            AWSShapeMember(label: "TreatmentName", required: false, type: .string), 
            AWSShapeMember(label: "Version", required: false, type: .integer), 
            AWSShapeMember(label: "tags", location: .body(locationName: "tags"), required: false, type: .map)
        ]
        /// Treatments that are defined in addition to the default treatment.
        public let additionalTreatments: [TreatmentResource]?
        /// The ID of the application to which the campaign applies.
        public let applicationId: String?
        /// The arn for the campaign.
        public let arn: String?
        /// The date the campaign was created in ISO 8601 format.
        public let creationDate: String?
        /// The status of the campaign's default treatment. Only present for A/B test campaigns.
        public let defaultState: CampaignState?
        /// A description of the campaign.
        public let description: String?
        /// The allocated percentage of end users who will not receive messages from this campaign.
        public let holdoutPercent: Int32?
        /// Campaign hook information.
        public let hook: CampaignHook?
        /// The unique campaign ID.
        public let id: String?
        /// Indicates whether the campaign is paused. A paused campaign does not send messages unless you resume it by setting IsPaused to false.
        public let isPaused: Bool?
        /// The date the campaign was last updated in ISO 8601 format.	
        public let lastModifiedDate: String?
        /// The campaign limits settings.
        public let limits: CampaignLimits?
        /// The message configuration settings.
        public let messageConfiguration: MessageConfiguration?
        /// The custom name of the campaign.
        public let name: String?
        /// The campaign schedule.
        public let schedule: Schedule?
        /// The ID of the segment to which the campaign sends messages.
        public let segmentId: String?
        /// The version of the segment to which the campaign sends messages.
        public let segmentVersion: Int32?
        /// The campaign status.
        /// An A/B test campaign will have a status of COMPLETED only when all treatments have a status of COMPLETED.
        public let state: CampaignState?
        /// A custom description for the treatment.
        public let treatmentDescription: String?
        /// The custom name of a variation of the campaign used for A/B testing.
        public let treatmentName: String?
        /// The campaign version number.
        public let version: Int32?
        /// The Tags for the campaign.
        public let tags: [String: String]?

        public init(additionalTreatments: [TreatmentResource]? = nil, applicationId: String? = nil, arn: String? = nil, creationDate: String? = nil, defaultState: CampaignState? = nil, description: String? = nil, holdoutPercent: Int32? = nil, hook: CampaignHook? = nil, id: String? = nil, isPaused: Bool? = nil, lastModifiedDate: String? = nil, limits: CampaignLimits? = nil, messageConfiguration: MessageConfiguration? = nil, name: String? = nil, schedule: Schedule? = nil, segmentId: String? = nil, segmentVersion: Int32? = nil, state: CampaignState? = nil, tags: [String: String]? = nil, treatmentDescription: String? = nil, treatmentName: String? = nil, version: Int32? = nil) {
            self.additionalTreatments = additionalTreatments
            self.applicationId = applicationId
            self.arn = arn
            self.creationDate = creationDate
            self.defaultState = defaultState
            self.description = description
            self.holdoutPercent = holdoutPercent
            self.hook = hook
            self.id = id
            self.isPaused = isPaused
            self.lastModifiedDate = lastModifiedDate
            self.limits = limits
            self.messageConfiguration = messageConfiguration
            self.name = name
            self.schedule = schedule
            self.segmentId = segmentId
            self.segmentVersion = segmentVersion
            self.state = state
            self.treatmentDescription = treatmentDescription
            self.treatmentName = treatmentName
            self.version = version
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case additionalTreatments = "AdditionalTreatments"
            case applicationId = "ApplicationId"
            case arn = "Arn"
            case creationDate = "CreationDate"
            case defaultState = "DefaultState"
            case description = "Description"
            case holdoutPercent = "HoldoutPercent"
            case hook = "Hook"
            case id = "Id"
            case isPaused = "IsPaused"
            case lastModifiedDate = "LastModifiedDate"
            case limits = "Limits"
            case messageConfiguration = "MessageConfiguration"
            case name = "Name"
            case schedule = "Schedule"
            case segmentId = "SegmentId"
            case segmentVersion = "SegmentVersion"
            case state = "State"
            case treatmentDescription = "TreatmentDescription"
            case treatmentName = "TreatmentName"
            case version = "Version"
            case tags = "tags"
        }
    }

    public struct CampaignSmsMessage: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Body", required: false, type: .string), 
            AWSShapeMember(label: "MessageType", required: false, type: .enum), 
            AWSShapeMember(label: "SenderId", required: false, type: .string)
        ]
        /// The SMS text body.
        public let body: String?
        /// Is this is a transactional SMS message, otherwise a promotional message.
        public let messageType: MessageType?
        /// Sender ID of sent message.
        public let senderId: String?

        public init(body: String? = nil, messageType: MessageType? = nil, senderId: String? = nil) {
            self.body = body
            self.messageType = messageType
            self.senderId = senderId
        }

        private enum CodingKeys: String, CodingKey {
            case body = "Body"
            case messageType = "MessageType"
            case senderId = "SenderId"
        }
    }

    public struct CampaignState: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CampaignStatus", required: false, type: .enum)
        ]
        /// The status of the campaign, or the status of a treatment that belongs to an A/B test campaign.
        /// Valid values: SCHEDULED, EXECUTING, PENDING_NEXT_RUN, COMPLETED, PAUSED
        public let campaignStatus: CampaignStatus?

        public init(campaignStatus: CampaignStatus? = nil) {
            self.campaignStatus = campaignStatus
        }

        private enum CodingKeys: String, CodingKey {
            case campaignStatus = "CampaignStatus"
        }
    }

    public enum CampaignStatus: String, CustomStringConvertible, Codable {
        case scheduled = "SCHEDULED"
        case executing = "EXECUTING"
        case pendingNextRun = "PENDING_NEXT_RUN"
        case completed = "COMPLETED"
        case paused = "PAUSED"
        case deleted = "DELETED"
        public var description: String { return self.rawValue }
    }

    public struct CampaignsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Item", required: false, type: .list), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]
        /// A list of campaigns.
        public let item: [CampaignResponse]?
        /// The string that you use in a subsequent request to get the next page of results in a paginated response.
        public let nextToken: String?

        public init(item: [CampaignResponse]? = nil, nextToken: String? = nil) {
            self.item = item
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case item = "Item"
            case nextToken = "NextToken"
        }
    }

    public struct ChannelResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", required: false, type: .string), 
            AWSShapeMember(label: "CreationDate", required: false, type: .string), 
            AWSShapeMember(label: "Enabled", required: false, type: .boolean), 
            AWSShapeMember(label: "HasCredential", required: false, type: .boolean), 
            AWSShapeMember(label: "Id", required: false, type: .string), 
            AWSShapeMember(label: "IsArchived", required: false, type: .boolean), 
            AWSShapeMember(label: "LastModifiedBy", required: false, type: .string), 
            AWSShapeMember(label: "LastModifiedDate", required: false, type: .string), 
            AWSShapeMember(label: "Version", required: false, type: .integer)
        ]
        /// Application id
        public let applicationId: String?
        /// When was this segment created
        public let creationDate: String?
        /// If the channel is enabled for sending messages.
        public let enabled: Bool?
        /// Not used. Retained for backwards compatibility.
        public let hasCredential: Bool?
        /// Channel ID. Not used, only for backwards compatibility.
        public let id: String?
        /// Is this channel archived
        public let isArchived: Bool?
        /// Who made the last change
        public let lastModifiedBy: String?
        /// Last date this was updated
        public let lastModifiedDate: String?
        /// Version of channel
        public let version: Int32?

        public init(applicationId: String? = nil, creationDate: String? = nil, enabled: Bool? = nil, hasCredential: Bool? = nil, id: String? = nil, isArchived: Bool? = nil, lastModifiedBy: String? = nil, lastModifiedDate: String? = nil, version: Int32? = nil) {
            self.applicationId = applicationId
            self.creationDate = creationDate
            self.enabled = enabled
            self.hasCredential = hasCredential
            self.id = id
            self.isArchived = isArchived
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedDate = lastModifiedDate
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "ApplicationId"
            case creationDate = "CreationDate"
            case enabled = "Enabled"
            case hasCredential = "HasCredential"
            case id = "Id"
            case isArchived = "IsArchived"
            case lastModifiedBy = "LastModifiedBy"
            case lastModifiedDate = "LastModifiedDate"
            case version = "Version"
        }
    }

    public enum ChannelType: String, CustomStringConvertible, Codable {
        case gcm = "GCM"
        case apns = "APNS"
        case apnsSandbox = "APNS_SANDBOX"
        case apnsVoip = "APNS_VOIP"
        case apnsVoipSandbox = "APNS_VOIP_SANDBOX"
        case adm = "ADM"
        case sms = "SMS"
        case voice = "VOICE"
        case email = "EMAIL"
        case baidu = "BAIDU"
        case custom = "CUSTOM"
        public var description: String { return self.rawValue }
    }

    public struct ChannelsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Channels", required: false, type: .map)
        ]
        /// A map of channels, with the ChannelType as the key and the Channel as the value.
        public let channels: [String: ChannelResponse]?

        public init(channels: [String: ChannelResponse]? = nil) {
            self.channels = channels
        }

        private enum CodingKeys: String, CodingKey {
            case channels = "Channels"
        }
    }

    public struct CreateAppRequest: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "CreateApplicationRequest"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CreateApplicationRequest", required: true, type: .structure)
        ]
        public let createApplicationRequest: CreateApplicationRequest

        public init(createApplicationRequest: CreateApplicationRequest) {
            self.createApplicationRequest = createApplicationRequest
        }

        private enum CodingKeys: String, CodingKey {
            case createApplicationRequest = "CreateApplicationRequest"
        }
    }

    public struct CreateAppResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "ApplicationResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationResponse", required: true, type: .structure)
        ]
        public let applicationResponse: ApplicationResponse

        public init(applicationResponse: ApplicationResponse) {
            self.applicationResponse = applicationResponse
        }

        private enum CodingKeys: String, CodingKey {
            case applicationResponse = "ApplicationResponse"
        }
    }

    public struct CreateApplicationRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", required: false, type: .string), 
            AWSShapeMember(label: "tags", location: .body(locationName: "tags"), required: false, type: .map)
        ]
        /// The display name of the application. Used in the Amazon Pinpoint console.
        public let name: String?
        /// The Tags for the app.
        public let tags: [String: String]?

        public init(name: String? = nil, tags: [String: String]? = nil) {
            self.name = name
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case tags = "tags"
        }
    }

    public struct CreateCampaignRequest: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "WriteCampaignRequest"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string), 
            AWSShapeMember(label: "WriteCampaignRequest", required: true, type: .structure)
        ]
        public let applicationId: String
        public let writeCampaignRequest: WriteCampaignRequest

        public init(applicationId: String, writeCampaignRequest: WriteCampaignRequest) {
            self.applicationId = applicationId
            self.writeCampaignRequest = writeCampaignRequest
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
            case writeCampaignRequest = "WriteCampaignRequest"
        }
    }

    public struct CreateCampaignResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "CampaignResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CampaignResponse", required: true, type: .structure)
        ]
        public let campaignResponse: CampaignResponse

        public init(campaignResponse: CampaignResponse) {
            self.campaignResponse = campaignResponse
        }

        private enum CodingKeys: String, CodingKey {
            case campaignResponse = "CampaignResponse"
        }
    }

    public struct CreateExportJobRequest: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "ExportJobRequest"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string), 
            AWSShapeMember(label: "ExportJobRequest", required: true, type: .structure)
        ]
        public let applicationId: String
        public let exportJobRequest: ExportJobRequest

        public init(applicationId: String, exportJobRequest: ExportJobRequest) {
            self.applicationId = applicationId
            self.exportJobRequest = exportJobRequest
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
            case exportJobRequest = "ExportJobRequest"
        }
    }

    public struct CreateExportJobResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "ExportJobResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ExportJobResponse", required: true, type: .structure)
        ]
        public let exportJobResponse: ExportJobResponse

        public init(exportJobResponse: ExportJobResponse) {
            self.exportJobResponse = exportJobResponse
        }

        private enum CodingKeys: String, CodingKey {
            case exportJobResponse = "ExportJobResponse"
        }
    }

    public struct CreateImportJobRequest: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "ImportJobRequest"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string), 
            AWSShapeMember(label: "ImportJobRequest", required: true, type: .structure)
        ]
        public let applicationId: String
        public let importJobRequest: ImportJobRequest

        public init(applicationId: String, importJobRequest: ImportJobRequest) {
            self.applicationId = applicationId
            self.importJobRequest = importJobRequest
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
            case importJobRequest = "ImportJobRequest"
        }
    }

    public struct CreateImportJobResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "ImportJobResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ImportJobResponse", required: true, type: .structure)
        ]
        public let importJobResponse: ImportJobResponse

        public init(importJobResponse: ImportJobResponse) {
            self.importJobResponse = importJobResponse
        }

        private enum CodingKeys: String, CodingKey {
            case importJobResponse = "ImportJobResponse"
        }
    }

    public struct CreateSegmentRequest: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "WriteSegmentRequest"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string), 
            AWSShapeMember(label: "WriteSegmentRequest", required: true, type: .structure)
        ]
        public let applicationId: String
        public let writeSegmentRequest: WriteSegmentRequest

        public init(applicationId: String, writeSegmentRequest: WriteSegmentRequest) {
            self.applicationId = applicationId
            self.writeSegmentRequest = writeSegmentRequest
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
            case writeSegmentRequest = "WriteSegmentRequest"
        }
    }

    public struct CreateSegmentResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "SegmentResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SegmentResponse", required: true, type: .structure)
        ]
        public let segmentResponse: SegmentResponse

        public init(segmentResponse: SegmentResponse) {
            self.segmentResponse = segmentResponse
        }

        private enum CodingKeys: String, CodingKey {
            case segmentResponse = "SegmentResponse"
        }
    }

    public struct DefaultMessage: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Body", required: false, type: .string), 
            AWSShapeMember(label: "Substitutions", required: false, type: .map)
        ]
        /// The message body of the notification, the email body or the text message.
        public let body: String?
        /// Default message substitutions. Can be overridden by individual address substitutions.
        public let substitutions: [String: [String]]?

        public init(body: String? = nil, substitutions: [String: [String]]? = nil) {
            self.body = body
            self.substitutions = substitutions
        }

        private enum CodingKeys: String, CodingKey {
            case body = "Body"
            case substitutions = "Substitutions"
        }
    }

    public struct DefaultPushNotificationMessage: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Action", required: false, type: .enum), 
            AWSShapeMember(label: "Body", required: false, type: .string), 
            AWSShapeMember(label: "Data", required: false, type: .map), 
            AWSShapeMember(label: "SilentPush", required: false, type: .boolean), 
            AWSShapeMember(label: "Substitutions", required: false, type: .map), 
            AWSShapeMember(label: "Title", required: false, type: .string), 
            AWSShapeMember(label: "Url", required: false, type: .string)
        ]
        /// The action that occurs if the user taps a push notification delivered by the campaign: OPEN_APP - Your app launches, or it becomes the foreground app if it has been sent to the background. This is the default action. DEEP_LINK - Uses deep linking features in iOS and Android to open your app and display a designated user interface within the app. URL - The default mobile browser on the user's device launches and opens a web page at the URL you specify. Possible values include: OPEN_APP | DEEP_LINK | URL
        public let action: Action?
        /// The message body of the notification.
        public let body: String?
        /// The data payload used for a silent push. This payload is added to the notifications' data.pinpoint.jsonBody' object
        public let data: [String: String]?
        /// Indicates if the message should display on the recipient's device. You can use silent pushes for remote configuration or to deliver messages to in-app notification centers.
        public let silentPush: Bool?
        /// Default message substitutions. Can be overridden by individual address substitutions.
        public let substitutions: [String: [String]]?
        /// The message title that displays above the message on the user's device.
        public let title: String?
        /// The URL to open in the user's mobile browser. Used if the value for Action is URL.
        public let url: String?

        public init(action: Action? = nil, body: String? = nil, data: [String: String]? = nil, silentPush: Bool? = nil, substitutions: [String: [String]]? = nil, title: String? = nil, url: String? = nil) {
            self.action = action
            self.body = body
            self.data = data
            self.silentPush = silentPush
            self.substitutions = substitutions
            self.title = title
            self.url = url
        }

        private enum CodingKeys: String, CodingKey {
            case action = "Action"
            case body = "Body"
            case data = "Data"
            case silentPush = "SilentPush"
            case substitutions = "Substitutions"
            case title = "Title"
            case url = "Url"
        }
    }

    public struct DeleteAdmChannelRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let applicationId: String

        public init(applicationId: String) {
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
        }
    }

    public struct DeleteAdmChannelResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "ADMChannelResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ADMChannelResponse", required: true, type: .structure)
        ]
        public let aDMChannelResponse: ADMChannelResponse

        public init(aDMChannelResponse: ADMChannelResponse) {
            self.aDMChannelResponse = aDMChannelResponse
        }

        private enum CodingKeys: String, CodingKey {
            case aDMChannelResponse = "ADMChannelResponse"
        }
    }

    public struct DeleteApnsChannelRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let applicationId: String

        public init(applicationId: String) {
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
        }
    }

    public struct DeleteApnsChannelResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "APNSChannelResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "APNSChannelResponse", required: true, type: .structure)
        ]
        public let aPNSChannelResponse: APNSChannelResponse

        public init(aPNSChannelResponse: APNSChannelResponse) {
            self.aPNSChannelResponse = aPNSChannelResponse
        }

        private enum CodingKeys: String, CodingKey {
            case aPNSChannelResponse = "APNSChannelResponse"
        }
    }

    public struct DeleteApnsSandboxChannelRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let applicationId: String

        public init(applicationId: String) {
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
        }
    }

    public struct DeleteApnsSandboxChannelResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "APNSSandboxChannelResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "APNSSandboxChannelResponse", required: true, type: .structure)
        ]
        public let aPNSSandboxChannelResponse: APNSSandboxChannelResponse

        public init(aPNSSandboxChannelResponse: APNSSandboxChannelResponse) {
            self.aPNSSandboxChannelResponse = aPNSSandboxChannelResponse
        }

        private enum CodingKeys: String, CodingKey {
            case aPNSSandboxChannelResponse = "APNSSandboxChannelResponse"
        }
    }

    public struct DeleteApnsVoipChannelRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let applicationId: String

        public init(applicationId: String) {
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
        }
    }

    public struct DeleteApnsVoipChannelResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "APNSVoipChannelResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "APNSVoipChannelResponse", required: true, type: .structure)
        ]
        public let aPNSVoipChannelResponse: APNSVoipChannelResponse

        public init(aPNSVoipChannelResponse: APNSVoipChannelResponse) {
            self.aPNSVoipChannelResponse = aPNSVoipChannelResponse
        }

        private enum CodingKeys: String, CodingKey {
            case aPNSVoipChannelResponse = "APNSVoipChannelResponse"
        }
    }

    public struct DeleteApnsVoipSandboxChannelRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let applicationId: String

        public init(applicationId: String) {
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
        }
    }

    public struct DeleteApnsVoipSandboxChannelResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "APNSVoipSandboxChannelResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "APNSVoipSandboxChannelResponse", required: true, type: .structure)
        ]
        public let aPNSVoipSandboxChannelResponse: APNSVoipSandboxChannelResponse

        public init(aPNSVoipSandboxChannelResponse: APNSVoipSandboxChannelResponse) {
            self.aPNSVoipSandboxChannelResponse = aPNSVoipSandboxChannelResponse
        }

        private enum CodingKeys: String, CodingKey {
            case aPNSVoipSandboxChannelResponse = "APNSVoipSandboxChannelResponse"
        }
    }

    public struct DeleteAppRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let applicationId: String

        public init(applicationId: String) {
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
        }
    }

    public struct DeleteAppResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "ApplicationResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationResponse", required: true, type: .structure)
        ]
        public let applicationResponse: ApplicationResponse

        public init(applicationResponse: ApplicationResponse) {
            self.applicationResponse = applicationResponse
        }

        private enum CodingKeys: String, CodingKey {
            case applicationResponse = "ApplicationResponse"
        }
    }

    public struct DeleteBaiduChannelRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let applicationId: String

        public init(applicationId: String) {
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
        }
    }

    public struct DeleteBaiduChannelResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "BaiduChannelResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "BaiduChannelResponse", required: true, type: .structure)
        ]
        public let baiduChannelResponse: BaiduChannelResponse

        public init(baiduChannelResponse: BaiduChannelResponse) {
            self.baiduChannelResponse = baiduChannelResponse
        }

        private enum CodingKeys: String, CodingKey {
            case baiduChannelResponse = "BaiduChannelResponse"
        }
    }

    public struct DeleteCampaignRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string), 
            AWSShapeMember(label: "CampaignId", location: .uri(locationName: "campaign-id"), required: true, type: .string)
        ]
        public let applicationId: String
        public let campaignId: String

        public init(applicationId: String, campaignId: String) {
            self.applicationId = applicationId
            self.campaignId = campaignId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
            case campaignId = "campaign-id"
        }
    }

    public struct DeleteCampaignResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "CampaignResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CampaignResponse", required: true, type: .structure)
        ]
        public let campaignResponse: CampaignResponse

        public init(campaignResponse: CampaignResponse) {
            self.campaignResponse = campaignResponse
        }

        private enum CodingKeys: String, CodingKey {
            case campaignResponse = "CampaignResponse"
        }
    }

    public struct DeleteEmailChannelRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let applicationId: String

        public init(applicationId: String) {
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
        }
    }

    public struct DeleteEmailChannelResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "EmailChannelResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "EmailChannelResponse", required: true, type: .structure)
        ]
        public let emailChannelResponse: EmailChannelResponse

        public init(emailChannelResponse: EmailChannelResponse) {
            self.emailChannelResponse = emailChannelResponse
        }

        private enum CodingKeys: String, CodingKey {
            case emailChannelResponse = "EmailChannelResponse"
        }
    }

    public struct DeleteEndpointRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string), 
            AWSShapeMember(label: "EndpointId", location: .uri(locationName: "endpoint-id"), required: true, type: .string)
        ]
        public let applicationId: String
        public let endpointId: String

        public init(applicationId: String, endpointId: String) {
            self.applicationId = applicationId
            self.endpointId = endpointId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
            case endpointId = "endpoint-id"
        }
    }

    public struct DeleteEndpointResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "EndpointResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "EndpointResponse", required: true, type: .structure)
        ]
        public let endpointResponse: EndpointResponse

        public init(endpointResponse: EndpointResponse) {
            self.endpointResponse = endpointResponse
        }

        private enum CodingKeys: String, CodingKey {
            case endpointResponse = "EndpointResponse"
        }
    }

    public struct DeleteEventStreamRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let applicationId: String

        public init(applicationId: String) {
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
        }
    }

    public struct DeleteEventStreamResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "EventStream"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "EventStream", required: true, type: .structure)
        ]
        public let eventStream: EventStream

        public init(eventStream: EventStream) {
            self.eventStream = eventStream
        }

        private enum CodingKeys: String, CodingKey {
            case eventStream = "EventStream"
        }
    }

    public struct DeleteGcmChannelRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let applicationId: String

        public init(applicationId: String) {
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
        }
    }

    public struct DeleteGcmChannelResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "GCMChannelResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "GCMChannelResponse", required: true, type: .structure)
        ]
        public let gCMChannelResponse: GCMChannelResponse

        public init(gCMChannelResponse: GCMChannelResponse) {
            self.gCMChannelResponse = gCMChannelResponse
        }

        private enum CodingKeys: String, CodingKey {
            case gCMChannelResponse = "GCMChannelResponse"
        }
    }

    public struct DeleteSegmentRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string), 
            AWSShapeMember(label: "SegmentId", location: .uri(locationName: "segment-id"), required: true, type: .string)
        ]
        public let applicationId: String
        public let segmentId: String

        public init(applicationId: String, segmentId: String) {
            self.applicationId = applicationId
            self.segmentId = segmentId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
            case segmentId = "segment-id"
        }
    }

    public struct DeleteSegmentResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "SegmentResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SegmentResponse", required: true, type: .structure)
        ]
        public let segmentResponse: SegmentResponse

        public init(segmentResponse: SegmentResponse) {
            self.segmentResponse = segmentResponse
        }

        private enum CodingKeys: String, CodingKey {
            case segmentResponse = "SegmentResponse"
        }
    }

    public struct DeleteSmsChannelRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let applicationId: String

        public init(applicationId: String) {
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
        }
    }

    public struct DeleteSmsChannelResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "SMSChannelResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SMSChannelResponse", required: true, type: .structure)
        ]
        public let sMSChannelResponse: SMSChannelResponse

        public init(sMSChannelResponse: SMSChannelResponse) {
            self.sMSChannelResponse = sMSChannelResponse
        }

        private enum CodingKeys: String, CodingKey {
            case sMSChannelResponse = "SMSChannelResponse"
        }
    }

    public struct DeleteUserEndpointsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string), 
            AWSShapeMember(label: "UserId", location: .uri(locationName: "user-id"), required: true, type: .string)
        ]
        public let applicationId: String
        public let userId: String

        public init(applicationId: String, userId: String) {
            self.applicationId = applicationId
            self.userId = userId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
            case userId = "user-id"
        }
    }

    public struct DeleteUserEndpointsResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "EndpointsResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "EndpointsResponse", required: true, type: .structure)
        ]
        public let endpointsResponse: EndpointsResponse

        public init(endpointsResponse: EndpointsResponse) {
            self.endpointsResponse = endpointsResponse
        }

        private enum CodingKeys: String, CodingKey {
            case endpointsResponse = "EndpointsResponse"
        }
    }

    public struct DeleteVoiceChannelRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let applicationId: String

        public init(applicationId: String) {
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
        }
    }

    public struct DeleteVoiceChannelResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "VoiceChannelResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "VoiceChannelResponse", required: true, type: .structure)
        ]
        public let voiceChannelResponse: VoiceChannelResponse

        public init(voiceChannelResponse: VoiceChannelResponse) {
            self.voiceChannelResponse = voiceChannelResponse
        }

        private enum CodingKeys: String, CodingKey {
            case voiceChannelResponse = "VoiceChannelResponse"
        }
    }

    public enum DeliveryStatus: String, CustomStringConvertible, Codable {
        case successful = "SUCCESSFUL"
        case throttled = "THROTTLED"
        case temporaryFailure = "TEMPORARY_FAILURE"
        case permanentFailure = "PERMANENT_FAILURE"
        case unknownFailure = "UNKNOWN_FAILURE"
        case optOut = "OPT_OUT"
        case duplicate = "DUPLICATE"
        public var description: String { return self.rawValue }
    }

    public enum DimensionType: String, CustomStringConvertible, Codable {
        case inclusive = "INCLUSIVE"
        case exclusive = "EXCLUSIVE"
        public var description: String { return self.rawValue }
    }

    public struct DirectMessageConfiguration: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ADMMessage", required: false, type: .structure), 
            AWSShapeMember(label: "APNSMessage", required: false, type: .structure), 
            AWSShapeMember(label: "BaiduMessage", required: false, type: .structure), 
            AWSShapeMember(label: "DefaultMessage", required: false, type: .structure), 
            AWSShapeMember(label: "DefaultPushNotificationMessage", required: false, type: .structure), 
            AWSShapeMember(label: "EmailMessage", required: false, type: .structure), 
            AWSShapeMember(label: "GCMMessage", required: false, type: .structure), 
            AWSShapeMember(label: "SMSMessage", required: false, type: .structure), 
            AWSShapeMember(label: "VoiceMessage", required: false, type: .structure)
        ]
        /// The message to ADM channels. Overrides the default push notification message.
        public let aDMMessage: ADMMessage?
        /// The message to APNS channels. Overrides the default push notification message.
        public let aPNSMessage: APNSMessage?
        /// The message to Baidu GCM channels. Overrides the default push notification message.
        public let baiduMessage: BaiduMessage?
        /// The default message for all channels.
        public let defaultMessage: DefaultMessage?
        /// The default push notification message for all push channels.
        public let defaultPushNotificationMessage: DefaultPushNotificationMessage?
        /// The message to Email channels. Overrides the default message.
        public let emailMessage: EmailMessage?
        /// The message to GCM channels. Overrides the default push notification message.
        public let gCMMessage: GCMMessage?
        /// The message to SMS channels. Overrides the default message.
        public let sMSMessage: SMSMessage?
        /// The message to Voice channels. Overrides the default message.
        public let voiceMessage: VoiceMessage?

        public init(aDMMessage: ADMMessage? = nil, aPNSMessage: APNSMessage? = nil, baiduMessage: BaiduMessage? = nil, defaultMessage: DefaultMessage? = nil, defaultPushNotificationMessage: DefaultPushNotificationMessage? = nil, emailMessage: EmailMessage? = nil, gCMMessage: GCMMessage? = nil, sMSMessage: SMSMessage? = nil, voiceMessage: VoiceMessage? = nil) {
            self.aDMMessage = aDMMessage
            self.aPNSMessage = aPNSMessage
            self.baiduMessage = baiduMessage
            self.defaultMessage = defaultMessage
            self.defaultPushNotificationMessage = defaultPushNotificationMessage
            self.emailMessage = emailMessage
            self.gCMMessage = gCMMessage
            self.sMSMessage = sMSMessage
            self.voiceMessage = voiceMessage
        }

        private enum CodingKeys: String, CodingKey {
            case aDMMessage = "ADMMessage"
            case aPNSMessage = "APNSMessage"
            case baiduMessage = "BaiduMessage"
            case defaultMessage = "DefaultMessage"
            case defaultPushNotificationMessage = "DefaultPushNotificationMessage"
            case emailMessage = "EmailMessage"
            case gCMMessage = "GCMMessage"
            case sMSMessage = "SMSMessage"
            case voiceMessage = "VoiceMessage"
        }
    }

    public enum Duration: String, CustomStringConvertible, Codable {
        case hr24 = "HR_24"
        case day7 = "DAY_7"
        case day14 = "DAY_14"
        case day30 = "DAY_30"
        public var description: String { return self.rawValue }
    }

    public struct EmailChannelRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ConfigurationSet", required: false, type: .string), 
            AWSShapeMember(label: "Enabled", required: false, type: .boolean), 
            AWSShapeMember(label: "FromAddress", required: false, type: .string), 
            AWSShapeMember(label: "Identity", required: false, type: .string), 
            AWSShapeMember(label: "RoleArn", required: false, type: .string)
        ]
        /// The configuration set that you want to use when you send email using the Pinpoint Email API.
        public let configurationSet: String?
        /// If the channel is enabled for sending messages.
        public let enabled: Bool?
        /// The email address used to send emails from.
        public let fromAddress: String?
        /// The ARN of an identity verified with SES.
        public let identity: String?
        /// The ARN of an IAM Role used to submit events to Mobile Analytics' event ingestion service
        public let roleArn: String?

        public init(configurationSet: String? = nil, enabled: Bool? = nil, fromAddress: String? = nil, identity: String? = nil, roleArn: String? = nil) {
            self.configurationSet = configurationSet
            self.enabled = enabled
            self.fromAddress = fromAddress
            self.identity = identity
            self.roleArn = roleArn
        }

        private enum CodingKeys: String, CodingKey {
            case configurationSet = "ConfigurationSet"
            case enabled = "Enabled"
            case fromAddress = "FromAddress"
            case identity = "Identity"
            case roleArn = "RoleArn"
        }
    }

    public struct EmailChannelResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", required: false, type: .string), 
            AWSShapeMember(label: "ConfigurationSet", required: false, type: .string), 
            AWSShapeMember(label: "CreationDate", required: false, type: .string), 
            AWSShapeMember(label: "Enabled", required: false, type: .boolean), 
            AWSShapeMember(label: "FromAddress", required: false, type: .string), 
            AWSShapeMember(label: "HasCredential", required: false, type: .boolean), 
            AWSShapeMember(label: "Id", required: false, type: .string), 
            AWSShapeMember(label: "Identity", required: false, type: .string), 
            AWSShapeMember(label: "IsArchived", required: false, type: .boolean), 
            AWSShapeMember(label: "LastModifiedBy", required: false, type: .string), 
            AWSShapeMember(label: "LastModifiedDate", required: false, type: .string), 
            AWSShapeMember(label: "MessagesPerSecond", required: false, type: .integer), 
            AWSShapeMember(label: "Platform", required: false, type: .string), 
            AWSShapeMember(label: "RoleArn", required: false, type: .string), 
            AWSShapeMember(label: "Version", required: false, type: .integer)
        ]
        /// The unique ID of the application to which the email channel belongs.
        public let applicationId: String?
        /// The configuration set that you want to use when you send email using the Pinpoint Email API.
        public let configurationSet: String?
        /// The date that the settings were last updated in ISO 8601 format.
        public let creationDate: String?
        /// If the channel is enabled for sending messages.
        public let enabled: Bool?
        /// The email address used to send emails from.
        public let fromAddress: String?
        /// Not used. Retained for backwards compatibility.
        public let hasCredential: Bool?
        /// Channel ID. Not used, only for backwards compatibility.
        public let id: String?
        /// The ARN of an identity verified with SES.
        public let identity: String?
        /// Is this channel archived
        public let isArchived: Bool?
        /// Who last updated this entry
        public let lastModifiedBy: String?
        /// Last date this was updated
        public let lastModifiedDate: String?
        /// Messages per second that can be sent
        public let messagesPerSecond: Int32?
        /// Platform type. Will be "EMAIL"
        public let platform: String?
        /// The ARN of an IAM Role used to submit events to Mobile Analytics' event ingestion service
        public let roleArn: String?
        /// Version of channel
        public let version: Int32?

        public init(applicationId: String? = nil, configurationSet: String? = nil, creationDate: String? = nil, enabled: Bool? = nil, fromAddress: String? = nil, hasCredential: Bool? = nil, id: String? = nil, identity: String? = nil, isArchived: Bool? = nil, lastModifiedBy: String? = nil, lastModifiedDate: String? = nil, messagesPerSecond: Int32? = nil, platform: String? = nil, roleArn: String? = nil, version: Int32? = nil) {
            self.applicationId = applicationId
            self.configurationSet = configurationSet
            self.creationDate = creationDate
            self.enabled = enabled
            self.fromAddress = fromAddress
            self.hasCredential = hasCredential
            self.id = id
            self.identity = identity
            self.isArchived = isArchived
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedDate = lastModifiedDate
            self.messagesPerSecond = messagesPerSecond
            self.platform = platform
            self.roleArn = roleArn
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "ApplicationId"
            case configurationSet = "ConfigurationSet"
            case creationDate = "CreationDate"
            case enabled = "Enabled"
            case fromAddress = "FromAddress"
            case hasCredential = "HasCredential"
            case id = "Id"
            case identity = "Identity"
            case isArchived = "IsArchived"
            case lastModifiedBy = "LastModifiedBy"
            case lastModifiedDate = "LastModifiedDate"
            case messagesPerSecond = "MessagesPerSecond"
            case platform = "Platform"
            case roleArn = "RoleArn"
            case version = "Version"
        }
    }

    public struct EmailMessage: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Body", required: false, type: .string), 
            AWSShapeMember(label: "FeedbackForwardingAddress", required: false, type: .string), 
            AWSShapeMember(label: "FromAddress", required: false, type: .string), 
            AWSShapeMember(label: "RawEmail", required: false, type: .structure), 
            AWSShapeMember(label: "ReplyToAddresses", required: false, type: .list), 
            AWSShapeMember(label: "SimpleEmail", required: false, type: .structure), 
            AWSShapeMember(label: "Substitutions", required: false, type: .map)
        ]
        /// The body of the email message.
        public let body: String?
        /// The email address that bounces and complaints will be forwarded to when feedback forwarding is enabled.
        public let feedbackForwardingAddress: String?
        /// The email address used to send the email from. Defaults to use FromAddress specified in the Email Channel.
        public let fromAddress: String?
        /// An email represented as a raw MIME message.
        public let rawEmail: RawEmail?
        /// The reply-to email address(es) for the email. If the recipient replies to the email, each reply-to address will receive the reply.
        public let replyToAddresses: [String]?
        /// An email composed of a subject, a text part and a html part.
        public let simpleEmail: SimpleEmail?
        /// Default message substitutions. Can be overridden by individual address substitutions.
        public let substitutions: [String: [String]]?

        public init(body: String? = nil, feedbackForwardingAddress: String? = nil, fromAddress: String? = nil, rawEmail: RawEmail? = nil, replyToAddresses: [String]? = nil, simpleEmail: SimpleEmail? = nil, substitutions: [String: [String]]? = nil) {
            self.body = body
            self.feedbackForwardingAddress = feedbackForwardingAddress
            self.fromAddress = fromAddress
            self.rawEmail = rawEmail
            self.replyToAddresses = replyToAddresses
            self.simpleEmail = simpleEmail
            self.substitutions = substitutions
        }

        private enum CodingKeys: String, CodingKey {
            case body = "Body"
            case feedbackForwardingAddress = "FeedbackForwardingAddress"
            case fromAddress = "FromAddress"
            case rawEmail = "RawEmail"
            case replyToAddresses = "ReplyToAddresses"
            case simpleEmail = "SimpleEmail"
            case substitutions = "Substitutions"
        }
    }

    public struct EndpointBatchItem: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Address", required: false, type: .string), 
            AWSShapeMember(label: "Attributes", required: false, type: .map), 
            AWSShapeMember(label: "ChannelType", required: false, type: .enum), 
            AWSShapeMember(label: "Demographic", required: false, type: .structure), 
            AWSShapeMember(label: "EffectiveDate", required: false, type: .string), 
            AWSShapeMember(label: "EndpointStatus", required: false, type: .string), 
            AWSShapeMember(label: "Id", required: false, type: .string), 
            AWSShapeMember(label: "Location", required: false, type: .structure), 
            AWSShapeMember(label: "Metrics", required: false, type: .map), 
            AWSShapeMember(label: "OptOut", required: false, type: .string), 
            AWSShapeMember(label: "RequestId", required: false, type: .string), 
            AWSShapeMember(label: "User", required: false, type: .structure)
        ]
        /// The destination for messages that you send to this endpoint. The address varies by channel. For mobile push channels, use the token provided by the push notification service, such as the APNs device token or the FCM registration token. For the SMS channel, use a phone number in E.164 format, such as +12065550100. For the email channel, use an email address.
        public let address: String?
        /// Custom attributes that describe the endpoint by associating a name with an array of values. For example, an attribute named "interests" might have the values ["science", "politics", "travel"]. You can use these attributes as selection criteria when you create a segment of users to engage with a messaging campaign.
        /// The following characters are not recommended in attribute names: # : ? \ /. The Amazon Pinpoint console does not display attributes that include these characters in the name. This limitation does not apply to attribute values.
        public let attributes: [String: [String]]?
        /// The channel type.
        /// Valid values: GCM | APNS | APNS_SANDBOX | APNS_VOIP | APNS_VOIP_SANDBOX | ADM | SMS | EMAIL | BAIDU
        public let channelType: ChannelType?
        /// The endpoint demographic attributes.
        public let demographic: EndpointDemographic?
        /// The last time the endpoint was updated. Provided in ISO 8601 format.
        public let effectiveDate: String?
        /// Unused.
        public let endpointStatus: String?
        /// The unique Id for the Endpoint in the batch.
        public let id: String?
        /// The endpoint location attributes.
        public let location: EndpointLocation?
        /// Custom metrics that your app reports to Amazon Pinpoint.
        public let metrics: [String: Double]?
        /// Indicates whether a user has opted out of receiving messages with one of the following values:
        /// ALL - User has opted out of all messages.
        /// NONE - Users has not opted out and receives all messages.
        public let optOut: String?
        /// The unique ID for the most recent request to update the endpoint.
        public let requestId: String?
        /// Custom user-specific attributes that your app reports to Amazon Pinpoint.
        public let user: EndpointUser?

        public init(address: String? = nil, attributes: [String: [String]]? = nil, channelType: ChannelType? = nil, demographic: EndpointDemographic? = nil, effectiveDate: String? = nil, endpointStatus: String? = nil, id: String? = nil, location: EndpointLocation? = nil, metrics: [String: Double]? = nil, optOut: String? = nil, requestId: String? = nil, user: EndpointUser? = nil) {
            self.address = address
            self.attributes = attributes
            self.channelType = channelType
            self.demographic = demographic
            self.effectiveDate = effectiveDate
            self.endpointStatus = endpointStatus
            self.id = id
            self.location = location
            self.metrics = metrics
            self.optOut = optOut
            self.requestId = requestId
            self.user = user
        }

        private enum CodingKeys: String, CodingKey {
            case address = "Address"
            case attributes = "Attributes"
            case channelType = "ChannelType"
            case demographic = "Demographic"
            case effectiveDate = "EffectiveDate"
            case endpointStatus = "EndpointStatus"
            case id = "Id"
            case location = "Location"
            case metrics = "Metrics"
            case optOut = "OptOut"
            case requestId = "RequestId"
            case user = "User"
        }
    }

    public struct EndpointBatchRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Item", required: false, type: .list)
        ]
        /// List of items to update. Maximum 100 items
        public let item: [EndpointBatchItem]?

        public init(item: [EndpointBatchItem]? = nil) {
            self.item = item
        }

        private enum CodingKeys: String, CodingKey {
            case item = "Item"
        }
    }

    public struct EndpointDemographic: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AppVersion", required: false, type: .string), 
            AWSShapeMember(label: "Locale", required: false, type: .string), 
            AWSShapeMember(label: "Make", required: false, type: .string), 
            AWSShapeMember(label: "Model", required: false, type: .string), 
            AWSShapeMember(label: "ModelVersion", required: false, type: .string), 
            AWSShapeMember(label: "Platform", required: false, type: .string), 
            AWSShapeMember(label: "PlatformVersion", required: false, type: .string), 
            AWSShapeMember(label: "Timezone", required: false, type: .string)
        ]
        /// The version of the application associated with the endpoint.
        public let appVersion: String?
        /// The endpoint locale in the following format: The ISO 639-1 alpha-2 code, followed by an underscore, followed by an ISO 3166-1 alpha-2 value.
        public let locale: String?
        /// The manufacturer of the endpoint device, such as Apple or Samsung.
        public let make: String?
        /// The model name or number of the endpoint device, such as iPhone.
        public let model: String?
        /// The model version of the endpoint device.
        public let modelVersion: String?
        /// The platform of the endpoint device, such as iOS or Android.
        public let platform: String?
        /// The platform version of the endpoint device.
        public let platformVersion: String?
        /// The timezone of the endpoint. Specified as a tz database value, such as Americas/Los_Angeles.
        public let timezone: String?

        public init(appVersion: String? = nil, locale: String? = nil, make: String? = nil, model: String? = nil, modelVersion: String? = nil, platform: String? = nil, platformVersion: String? = nil, timezone: String? = nil) {
            self.appVersion = appVersion
            self.locale = locale
            self.make = make
            self.model = model
            self.modelVersion = modelVersion
            self.platform = platform
            self.platformVersion = platformVersion
            self.timezone = timezone
        }

        private enum CodingKeys: String, CodingKey {
            case appVersion = "AppVersion"
            case locale = "Locale"
            case make = "Make"
            case model = "Model"
            case modelVersion = "ModelVersion"
            case platform = "Platform"
            case platformVersion = "PlatformVersion"
            case timezone = "Timezone"
        }
    }

    public struct EndpointItemResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Message", required: false, type: .string), 
            AWSShapeMember(label: "StatusCode", required: false, type: .integer)
        ]
        /// A custom message associated with the registration of an endpoint when issuing a response.
        public let message: String?
        /// The status code associated with the merging of an endpoint when issuing a response.
        public let statusCode: Int32?

        public init(message: String? = nil, statusCode: Int32? = nil) {
            self.message = message
            self.statusCode = statusCode
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case statusCode = "StatusCode"
        }
    }

    public struct EndpointLocation: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "City", required: false, type: .string), 
            AWSShapeMember(label: "Country", required: false, type: .string), 
            AWSShapeMember(label: "Latitude", required: false, type: .double), 
            AWSShapeMember(label: "Longitude", required: false, type: .double), 
            AWSShapeMember(label: "PostalCode", required: false, type: .string), 
            AWSShapeMember(label: "Region", required: false, type: .string)
        ]
        /// The city where the endpoint is located.
        public let city: String?
        /// The two-letter code for the country or region of the endpoint. Specified as an ISO 3166-1 alpha-2 code, such as "US" for the United States.
        public let country: String?
        /// The latitude of the endpoint location, rounded to one decimal place.
        public let latitude: Double?
        /// The longitude of the endpoint location, rounded to one decimal place.
        public let longitude: Double?
        /// The postal code or zip code of the endpoint.
        public let postalCode: String?
        /// The region of the endpoint location. For example, in the United States, this corresponds to a state.
        public let region: String?

        public init(city: String? = nil, country: String? = nil, latitude: Double? = nil, longitude: Double? = nil, postalCode: String? = nil, region: String? = nil) {
            self.city = city
            self.country = country
            self.latitude = latitude
            self.longitude = longitude
            self.postalCode = postalCode
            self.region = region
        }

        private enum CodingKeys: String, CodingKey {
            case city = "City"
            case country = "Country"
            case latitude = "Latitude"
            case longitude = "Longitude"
            case postalCode = "PostalCode"
            case region = "Region"
        }
    }

    public struct EndpointMessageResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Address", required: false, type: .string), 
            AWSShapeMember(label: "DeliveryStatus", required: false, type: .enum), 
            AWSShapeMember(label: "MessageId", required: false, type: .string), 
            AWSShapeMember(label: "StatusCode", required: false, type: .integer), 
            AWSShapeMember(label: "StatusMessage", required: false, type: .string), 
            AWSShapeMember(label: "UpdatedToken", required: false, type: .string)
        ]
        /// Address that endpoint message was delivered to.
        public let address: String?
        /// The delivery status of the message. Possible values:
        /// SUCCESS - The message was successfully delivered to the endpoint.
        /// TRANSIENT_FAILURE - A temporary error occurred. Amazon Pinpoint will attempt to deliver the message again later.
        /// FAILURE_PERMANENT - An error occurred when delivering the message to the endpoint. Amazon Pinpoint won't attempt to send the message again.
        /// TIMEOUT - The message couldn't be sent within the timeout period.
        /// QUIET_TIME - The local time for the endpoint was within the QuietTime for the campaign or app.
        /// DAILY_CAP - The endpoint has received the maximum number of messages it can receive within a 24-hour period.
        /// HOLDOUT - The endpoint was in a hold out treatment for the campaign.
        /// THROTTLED - Amazon Pinpoint throttled sending to this endpoint.
        /// EXPIRED - The endpoint address is expired.
        /// CAMPAIGN_CAP - The endpoint received the maximum number of messages allowed by the campaign.
        /// SERVICE_FAILURE - A service-level failure prevented Amazon Pinpoint from delivering the message.
        /// UNKNOWN - An unknown error occurred.
        public let deliveryStatus: DeliveryStatus?
        /// Unique message identifier associated with the message that was sent.
        public let messageId: String?
        /// Downstream service status code.
        public let statusCode: Int32?
        /// Status message for message delivery.
        public let statusMessage: String?
        /// If token was updated as part of delivery. (This is GCM Specific)
        public let updatedToken: String?

        public init(address: String? = nil, deliveryStatus: DeliveryStatus? = nil, messageId: String? = nil, statusCode: Int32? = nil, statusMessage: String? = nil, updatedToken: String? = nil) {
            self.address = address
            self.deliveryStatus = deliveryStatus
            self.messageId = messageId
            self.statusCode = statusCode
            self.statusMessage = statusMessage
            self.updatedToken = updatedToken
        }

        private enum CodingKeys: String, CodingKey {
            case address = "Address"
            case deliveryStatus = "DeliveryStatus"
            case messageId = "MessageId"
            case statusCode = "StatusCode"
            case statusMessage = "StatusMessage"
            case updatedToken = "UpdatedToken"
        }
    }

    public struct EndpointRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Address", required: false, type: .string), 
            AWSShapeMember(label: "Attributes", required: false, type: .map), 
            AWSShapeMember(label: "ChannelType", required: false, type: .enum), 
            AWSShapeMember(label: "Demographic", required: false, type: .structure), 
            AWSShapeMember(label: "EffectiveDate", required: false, type: .string), 
            AWSShapeMember(label: "EndpointStatus", required: false, type: .string), 
            AWSShapeMember(label: "Location", required: false, type: .structure), 
            AWSShapeMember(label: "Metrics", required: false, type: .map), 
            AWSShapeMember(label: "OptOut", required: false, type: .string), 
            AWSShapeMember(label: "RequestId", required: false, type: .string), 
            AWSShapeMember(label: "User", required: false, type: .structure)
        ]
        /// The destination for messages that you send to this endpoint. The address varies by channel. For mobile push channels, use the token provided by the push notification service, such as the APNs device token or the FCM registration token. For the SMS channel, use a phone number in E.164 format, such as +12065550100. For the email channel, use an email address.
        public let address: String?
        /// Custom attributes that describe the endpoint by associating a name with an array of values. For example, an attribute named "interests" might have the values ["science", "politics", "travel"]. You can use these attributes as selection criteria when you create a segment of users to engage with a messaging campaign.
        /// The following characters are not recommended in attribute names: # : ? \ /. The Amazon Pinpoint console does not display attributes that include these characters in the name. This limitation does not apply to attribute values.
        public let attributes: [String: [String]]?
        /// The channel type.
        /// Valid values: GCM | APNS | APNS_SANDBOX | APNS_VOIP | APNS_VOIP_SANDBOX | ADM | SMS | EMAIL | BAIDU
        public let channelType: ChannelType?
        /// Demographic attributes for the endpoint.
        public let demographic: EndpointDemographic?
        /// The date and time when the endpoint was updated, shown in ISO 8601 format.
        public let effectiveDate: String?
        /// Unused.
        public let endpointStatus: String?
        /// The endpoint location attributes.
        public let location: EndpointLocation?
        /// Custom metrics that your app reports to Amazon Pinpoint.
        public let metrics: [String: Double]?
        /// Indicates whether a user has opted out of receiving messages with one of the following values:
        /// ALL - User has opted out of all messages.
        /// NONE - Users has not opted out and receives all messages.
        public let optOut: String?
        /// The unique ID for the most recent request to update the endpoint.
        public let requestId: String?
        /// Custom user-specific attributes that your app reports to Amazon Pinpoint.
        public let user: EndpointUser?

        public init(address: String? = nil, attributes: [String: [String]]? = nil, channelType: ChannelType? = nil, demographic: EndpointDemographic? = nil, effectiveDate: String? = nil, endpointStatus: String? = nil, location: EndpointLocation? = nil, metrics: [String: Double]? = nil, optOut: String? = nil, requestId: String? = nil, user: EndpointUser? = nil) {
            self.address = address
            self.attributes = attributes
            self.channelType = channelType
            self.demographic = demographic
            self.effectiveDate = effectiveDate
            self.endpointStatus = endpointStatus
            self.location = location
            self.metrics = metrics
            self.optOut = optOut
            self.requestId = requestId
            self.user = user
        }

        private enum CodingKeys: String, CodingKey {
            case address = "Address"
            case attributes = "Attributes"
            case channelType = "ChannelType"
            case demographic = "Demographic"
            case effectiveDate = "EffectiveDate"
            case endpointStatus = "EndpointStatus"
            case location = "Location"
            case metrics = "Metrics"
            case optOut = "OptOut"
            case requestId = "RequestId"
            case user = "User"
        }
    }

    public struct EndpointResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Address", required: false, type: .string), 
            AWSShapeMember(label: "ApplicationId", required: false, type: .string), 
            AWSShapeMember(label: "Attributes", required: false, type: .map), 
            AWSShapeMember(label: "ChannelType", required: false, type: .enum), 
            AWSShapeMember(label: "CohortId", required: false, type: .string), 
            AWSShapeMember(label: "CreationDate", required: false, type: .string), 
            AWSShapeMember(label: "Demographic", required: false, type: .structure), 
            AWSShapeMember(label: "EffectiveDate", required: false, type: .string), 
            AWSShapeMember(label: "EndpointStatus", required: false, type: .string), 
            AWSShapeMember(label: "Id", required: false, type: .string), 
            AWSShapeMember(label: "Location", required: false, type: .structure), 
            AWSShapeMember(label: "Metrics", required: false, type: .map), 
            AWSShapeMember(label: "OptOut", required: false, type: .string), 
            AWSShapeMember(label: "RequestId", required: false, type: .string), 
            AWSShapeMember(label: "User", required: false, type: .structure)
        ]
        /// The address of the endpoint as provided by your push provider. For example, the DeviceToken or RegistrationId.
        public let address: String?
        /// The ID of the application that is associated with the endpoint.
        public let applicationId: String?
        /// Custom attributes that describe the endpoint by associating a name with an array of values. For example, an attribute named "interests" might have the following values: ["science", "politics", "travel"]. You can use these attributes as selection criteria when you create segments.
        /// The Amazon Pinpoint console can't display attribute names that include the following characters: hash/pound sign (#), colon (:), question mark (?), backslash (\), and forward slash (/). For this reason, you should avoid using these characters in the names of custom attributes.
        public let attributes: [String: [String]]?
        /// The channel type.
        /// Valid values: GCM | APNS | APNS_SANDBOX | APNS_VOIP | APNS_VOIP_SANDBOX | ADM | SMS | EMAIL | BAIDU
        public let channelType: ChannelType?
        /// A number from 0-99 that represents the cohort the endpoint is assigned to. Endpoints are grouped into cohorts randomly, and each cohort contains approximately 1 percent of the endpoints for an app. Amazon Pinpoint assigns cohorts to the holdout or treatment allocations for a campaign.
        public let cohortId: String?
        /// The date and time when the endpoint was created, shown in ISO 8601 format.
        public let creationDate: String?
        /// The endpoint demographic attributes.
        public let demographic: EndpointDemographic?
        /// The date and time when the endpoint was last updated, shown in ISO 8601 format.
        public let effectiveDate: String?
        /// Unused.
        public let endpointStatus: String?
        /// The unique ID that you assigned to the endpoint. The ID should be a globally unique identifier (GUID) to ensure that it doesn't conflict with other endpoint IDs associated with the application.
        public let id: String?
        /// The endpoint location attributes.
        public let location: EndpointLocation?
        /// Custom metrics that your app reports to Amazon Pinpoint.
        public let metrics: [String: Double]?
        /// Indicates whether a user has opted out of receiving messages with one of the following values:
        /// ALL - User has opted out of all messages.
        /// NONE - Users has not opted out and receives all messages.
        public let optOut: String?
        /// The unique ID for the most recent request to update the endpoint.
        public let requestId: String?
        /// Custom user-specific attributes that your app reports to Amazon Pinpoint.
        public let user: EndpointUser?

        public init(address: String? = nil, applicationId: String? = nil, attributes: [String: [String]]? = nil, channelType: ChannelType? = nil, cohortId: String? = nil, creationDate: String? = nil, demographic: EndpointDemographic? = nil, effectiveDate: String? = nil, endpointStatus: String? = nil, id: String? = nil, location: EndpointLocation? = nil, metrics: [String: Double]? = nil, optOut: String? = nil, requestId: String? = nil, user: EndpointUser? = nil) {
            self.address = address
            self.applicationId = applicationId
            self.attributes = attributes
            self.channelType = channelType
            self.cohortId = cohortId
            self.creationDate = creationDate
            self.demographic = demographic
            self.effectiveDate = effectiveDate
            self.endpointStatus = endpointStatus
            self.id = id
            self.location = location
            self.metrics = metrics
            self.optOut = optOut
            self.requestId = requestId
            self.user = user
        }

        private enum CodingKeys: String, CodingKey {
            case address = "Address"
            case applicationId = "ApplicationId"
            case attributes = "Attributes"
            case channelType = "ChannelType"
            case cohortId = "CohortId"
            case creationDate = "CreationDate"
            case demographic = "Demographic"
            case effectiveDate = "EffectiveDate"
            case endpointStatus = "EndpointStatus"
            case id = "Id"
            case location = "Location"
            case metrics = "Metrics"
            case optOut = "OptOut"
            case requestId = "RequestId"
            case user = "User"
        }
    }

    public struct EndpointSendConfiguration: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "BodyOverride", required: false, type: .string), 
            AWSShapeMember(label: "Context", required: false, type: .map), 
            AWSShapeMember(label: "RawContent", required: false, type: .string), 
            AWSShapeMember(label: "Substitutions", required: false, type: .map), 
            AWSShapeMember(label: "TitleOverride", required: false, type: .string)
        ]
        /// Body override. If specified will override default body.
        public let bodyOverride: String?
        /// A map of custom attributes to attributes to be attached to the message for this address. This payload is added to the push notification's 'data.pinpoint' object or added to the email/sms delivery receipt event attributes.
        public let context: [String: String]?
        /// The Raw JSON formatted string to be used as the payload. This value overrides the message.
        public let rawContent: String?
        /// A map of substitution values for the message to be merged with the DefaultMessage's substitutions. Substitutions on this map take precedence over the all other substitutions.
        public let substitutions: [String: [String]]?
        /// Title override. If specified will override default title if applicable.
        public let titleOverride: String?

        public init(bodyOverride: String? = nil, context: [String: String]? = nil, rawContent: String? = nil, substitutions: [String: [String]]? = nil, titleOverride: String? = nil) {
            self.bodyOverride = bodyOverride
            self.context = context
            self.rawContent = rawContent
            self.substitutions = substitutions
            self.titleOverride = titleOverride
        }

        private enum CodingKeys: String, CodingKey {
            case bodyOverride = "BodyOverride"
            case context = "Context"
            case rawContent = "RawContent"
            case substitutions = "Substitutions"
            case titleOverride = "TitleOverride"
        }
    }

    public struct EndpointUser: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "UserAttributes", required: false, type: .map), 
            AWSShapeMember(label: "UserId", required: false, type: .string)
        ]
        /// Custom attributes that describe the user by associating a name with an array of values. For example, an attribute named "interests" might have the following values: ["science", "politics", "travel"]. You can use these attributes as selection criteria when you create segments.
        /// The Amazon Pinpoint console can't display attribute names that include the following characters: hash/pound sign (#), colon (:), question mark (?), backslash (\), and forward slash (/). For this reason, you should avoid using these characters in the names of custom attributes.
        public let userAttributes: [String: [String]]?
        /// The unique ID of the user.
        public let userId: String?

        public init(userAttributes: [String: [String]]? = nil, userId: String? = nil) {
            self.userAttributes = userAttributes
            self.userId = userId
        }

        private enum CodingKeys: String, CodingKey {
            case userAttributes = "UserAttributes"
            case userId = "UserId"
        }
    }

    public struct EndpointsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Item", required: false, type: .list)
        ]
        /// The list of endpoints.
        public let item: [EndpointResponse]?

        public init(item: [EndpointResponse]? = nil) {
            self.item = item
        }

        private enum CodingKeys: String, CodingKey {
            case item = "Item"
        }
    }

    public struct Event: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AppPackageName", required: false, type: .string), 
            AWSShapeMember(label: "AppTitle", required: false, type: .string), 
            AWSShapeMember(label: "AppVersionCode", required: false, type: .string), 
            AWSShapeMember(label: "Attributes", required: false, type: .map), 
            AWSShapeMember(label: "ClientSdkVersion", required: false, type: .string), 
            AWSShapeMember(label: "EventType", required: false, type: .string), 
            AWSShapeMember(label: "Metrics", required: false, type: .map), 
            AWSShapeMember(label: "SdkName", required: false, type: .string), 
            AWSShapeMember(label: "Session", required: false, type: .structure), 
            AWSShapeMember(label: "Timestamp", required: false, type: .string)
        ]
        /// The package name associated with the app that's recording the event.
        public let appPackageName: String?
        /// The title of the app that's recording the event.
        public let appTitle: String?
        /// The version number of the app that's recording the event.
        public let appVersionCode: String?
        /// Custom attributes that are associated with the event you're adding or updating.
        public let attributes: [String: String]?
        /// The version of the SDK that's running on the client device.
        public let clientSdkVersion: String?
        /// The name of the custom event that you're recording.
        public let eventType: String?
        /// Custom metrics related to the event.
        public let metrics: [String: Double]?
        /// The name of the SDK that's being used to record the event.
        public let sdkName: String?
        /// Information about the session in which the event occurred.
        public let session: Session?
        /// The date and time when the event occurred, in ISO 8601 format.
        public let timestamp: String?

        public init(appPackageName: String? = nil, appTitle: String? = nil, appVersionCode: String? = nil, attributes: [String: String]? = nil, clientSdkVersion: String? = nil, eventType: String? = nil, metrics: [String: Double]? = nil, sdkName: String? = nil, session: Session? = nil, timestamp: String? = nil) {
            self.appPackageName = appPackageName
            self.appTitle = appTitle
            self.appVersionCode = appVersionCode
            self.attributes = attributes
            self.clientSdkVersion = clientSdkVersion
            self.eventType = eventType
            self.metrics = metrics
            self.sdkName = sdkName
            self.session = session
            self.timestamp = timestamp
        }

        private enum CodingKeys: String, CodingKey {
            case appPackageName = "AppPackageName"
            case appTitle = "AppTitle"
            case appVersionCode = "AppVersionCode"
            case attributes = "Attributes"
            case clientSdkVersion = "ClientSdkVersion"
            case eventType = "EventType"
            case metrics = "Metrics"
            case sdkName = "SdkName"
            case session = "Session"
            case timestamp = "Timestamp"
        }
    }

    public struct EventDimensions: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Attributes", required: false, type: .map), 
            AWSShapeMember(label: "EventType", required: false, type: .structure), 
            AWSShapeMember(label: "Metrics", required: false, type: .map)
        ]
        /// Custom attributes that your app reports to Amazon Pinpoint. You can use these attributes as selection criteria when you create an event filter.
        public let attributes: [String: AttributeDimension]?
        /// The name of the event that causes the campaign to be sent. This can be a standard event type that Amazon Pinpoint generates, such as _session.start, or a custom event that's specific to your app.
        public let eventType: SetDimension?
        /// Custom metrics that your app reports to Amazon Pinpoint. You can use these attributes as selection criteria when you create an event filter.
        public let metrics: [String: MetricDimension]?

        public init(attributes: [String: AttributeDimension]? = nil, eventType: SetDimension? = nil, metrics: [String: MetricDimension]? = nil) {
            self.attributes = attributes
            self.eventType = eventType
            self.metrics = metrics
        }

        private enum CodingKeys: String, CodingKey {
            case attributes = "Attributes"
            case eventType = "EventType"
            case metrics = "Metrics"
        }
    }

    public struct EventItemResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Message", required: false, type: .string), 
            AWSShapeMember(label: "StatusCode", required: false, type: .integer)
        ]
        /// A custom message that is associated with the processing of an event.
        public let message: String?
        /// The status returned in the response as a result of processing the event.
        /// Possible values: 400 (for invalid events) and 202 (for events that were accepted).
        public let statusCode: Int32?

        public init(message: String? = nil, statusCode: Int32? = nil) {
            self.message = message
            self.statusCode = statusCode
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case statusCode = "StatusCode"
        }
    }

    public struct EventStream: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", required: false, type: .string), 
            AWSShapeMember(label: "DestinationStreamArn", required: false, type: .string), 
            AWSShapeMember(label: "ExternalId", required: false, type: .string), 
            AWSShapeMember(label: "LastModifiedDate", required: false, type: .string), 
            AWSShapeMember(label: "LastUpdatedBy", required: false, type: .string), 
            AWSShapeMember(label: "RoleArn", required: false, type: .string)
        ]
        /// The ID of the application from which events should be published.
        public let applicationId: String?
        /// The Amazon Resource Name (ARN) of the Amazon Kinesis stream or Firehose delivery stream to which you want to publish events.
        ///  Firehose ARN: arn:aws:firehose:REGION:ACCOUNT_ID:deliverystream/STREAM_NAME
        ///  Kinesis ARN: arn:aws:kinesis:REGION:ACCOUNT_ID:stream/STREAM_NAME
        public let destinationStreamArn: String?
        /// (Deprecated) Your AWS account ID, which you assigned to the ExternalID key in an IAM trust policy. Used by Amazon Pinpoint to assume an IAM role. This requirement is removed, and external IDs are not recommended for IAM roles assumed by Amazon Pinpoint.
        public let externalId: String?
        /// The date the event stream was last updated in ISO 8601 format.
        public let lastModifiedDate: String?
        /// The IAM user who last modified the event stream.
        public let lastUpdatedBy: String?
        /// The IAM role that authorizes Amazon Pinpoint to publish events to the stream in your account.
        public let roleArn: String?

        public init(applicationId: String? = nil, destinationStreamArn: String? = nil, externalId: String? = nil, lastModifiedDate: String? = nil, lastUpdatedBy: String? = nil, roleArn: String? = nil) {
            self.applicationId = applicationId
            self.destinationStreamArn = destinationStreamArn
            self.externalId = externalId
            self.lastModifiedDate = lastModifiedDate
            self.lastUpdatedBy = lastUpdatedBy
            self.roleArn = roleArn
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "ApplicationId"
            case destinationStreamArn = "DestinationStreamArn"
            case externalId = "ExternalId"
            case lastModifiedDate = "LastModifiedDate"
            case lastUpdatedBy = "LastUpdatedBy"
            case roleArn = "RoleArn"
        }
    }

    public struct EventsBatch: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Endpoint", required: false, type: .structure), 
            AWSShapeMember(label: "Events", required: false, type: .map)
        ]
        /// The PublicEndpoint attached to the EndpointId from the request.
        public let endpoint: PublicEndpoint?
        /// An object that contains a set of events associated with the endpoint.
        public let events: [String: Event]?

        public init(endpoint: PublicEndpoint? = nil, events: [String: Event]? = nil) {
            self.endpoint = endpoint
            self.events = events
        }

        private enum CodingKeys: String, CodingKey {
            case endpoint = "Endpoint"
            case events = "Events"
        }
    }

    public struct EventsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "BatchItem", required: false, type: .map)
        ]
        /// A batch of events to process. Each BatchItem consists of an endpoint ID as the key, and an EventsBatch object as the value.
        public let batchItem: [String: EventsBatch]?

        public init(batchItem: [String: EventsBatch]? = nil) {
            self.batchItem = batchItem
        }

        private enum CodingKeys: String, CodingKey {
            case batchItem = "BatchItem"
        }
    }

    public struct EventsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Results", required: false, type: .map)
        ]
        /// A map that contains a multipart response for each endpoint. Each item in this object uses the endpoint ID as the key, and the item response as the value.
        /// If no item response exists, the value can also be one of the following: 202 (if the request was processed successfully) or 400 (if the payload was invalid, or required fields were missing).
        public let results: [String: ItemResponse]?

        public init(results: [String: ItemResponse]? = nil) {
            self.results = results
        }

        private enum CodingKeys: String, CodingKey {
            case results = "Results"
        }
    }

    public struct ExportJobRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "RoleArn", required: false, type: .string), 
            AWSShapeMember(label: "S3UrlPrefix", required: false, type: .string), 
            AWSShapeMember(label: "SegmentId", required: false, type: .string), 
            AWSShapeMember(label: "SegmentVersion", required: false, type: .integer)
        ]
        /// The Amazon Resource Name (ARN) of an IAM role that grants Amazon Pinpoint access to the Amazon S3 location that endpoints will be exported to.
        public let roleArn: String?
        /// A URL that points to the location within an Amazon S3 bucket that will receive the export. The location is typically a folder with multiple files.
        /// The URL should follow this format: s3://bucket-name/folder-name/
        /// Amazon Pinpoint will export endpoints to this location.
        public let s3UrlPrefix: String?
        /// The ID of the segment to export endpoints from. If not present, Amazon Pinpoint exports all of the endpoints that belong to the application.
        public let segmentId: String?
        /// The version of the segment to export if specified.
        public let segmentVersion: Int32?

        public init(roleArn: String? = nil, s3UrlPrefix: String? = nil, segmentId: String? = nil, segmentVersion: Int32? = nil) {
            self.roleArn = roleArn
            self.s3UrlPrefix = s3UrlPrefix
            self.segmentId = segmentId
            self.segmentVersion = segmentVersion
        }

        private enum CodingKeys: String, CodingKey {
            case roleArn = "RoleArn"
            case s3UrlPrefix = "S3UrlPrefix"
            case segmentId = "SegmentId"
            case segmentVersion = "SegmentVersion"
        }
    }

    public struct ExportJobResource: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "RoleArn", required: false, type: .string), 
            AWSShapeMember(label: "S3UrlPrefix", required: false, type: .string), 
            AWSShapeMember(label: "SegmentId", required: false, type: .string), 
            AWSShapeMember(label: "SegmentVersion", required: false, type: .integer)
        ]
        /// The Amazon Resource Name (ARN) of an IAM role that grants Amazon Pinpoint access to the Amazon S3 location that endpoints will be exported to.
        public let roleArn: String?
        /// A URL that points to the location within an Amazon S3 bucket that will receive the export. The location is typically a folder with multiple files.
        /// The URL should follow this format: s3://bucket-name/folder-name/
        /// Amazon Pinpoint will export endpoints to this location.
        public let s3UrlPrefix: String?
        /// The ID of the segment to export endpoints from. If not present, Amazon Pinpoint exports all of the endpoints that belong to the application.
        public let segmentId: String?
        /// The version of the segment to export if specified.
        public let segmentVersion: Int32?

        public init(roleArn: String? = nil, s3UrlPrefix: String? = nil, segmentId: String? = nil, segmentVersion: Int32? = nil) {
            self.roleArn = roleArn
            self.s3UrlPrefix = s3UrlPrefix
            self.segmentId = segmentId
            self.segmentVersion = segmentVersion
        }

        private enum CodingKeys: String, CodingKey {
            case roleArn = "RoleArn"
            case s3UrlPrefix = "S3UrlPrefix"
            case segmentId = "SegmentId"
            case segmentVersion = "SegmentVersion"
        }
    }

    public struct ExportJobResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", required: false, type: .string), 
            AWSShapeMember(label: "CompletedPieces", required: false, type: .integer), 
            AWSShapeMember(label: "CompletionDate", required: false, type: .string), 
            AWSShapeMember(label: "CreationDate", required: false, type: .string), 
            AWSShapeMember(label: "Definition", required: false, type: .structure), 
            AWSShapeMember(label: "FailedPieces", required: false, type: .integer), 
            AWSShapeMember(label: "Failures", required: false, type: .list), 
            AWSShapeMember(label: "Id", required: false, type: .string), 
            AWSShapeMember(label: "JobStatus", required: false, type: .enum), 
            AWSShapeMember(label: "TotalFailures", required: false, type: .integer), 
            AWSShapeMember(label: "TotalPieces", required: false, type: .integer), 
            AWSShapeMember(label: "TotalProcessed", required: false, type: .integer), 
            AWSShapeMember(label: "Type", required: false, type: .string)
        ]
        /// The unique ID of the application associated with the export job.
        public let applicationId: String?
        /// The number of pieces that have successfully completed as of the time of the request.
        public let completedPieces: Int32?
        /// The date the job completed in ISO 8601 format.
        public let completionDate: String?
        /// The date the job was created in ISO 8601 format.
        public let creationDate: String?
        /// The export job settings.
        public let definition: ExportJobResource?
        /// The number of pieces that failed to be processed as of the time of the request.
        public let failedPieces: Int32?
        /// Provides up to 100 of the first failed entries for the job, if any exist.
        public let failures: [String]?
        /// The unique ID of the job.
        public let id: String?
        /// The status of the job.
        /// Valid values: CREATED, INITIALIZING, PROCESSING, COMPLETING, COMPLETED, FAILING, FAILED
        /// The job status is FAILED if one or more pieces failed.
        public let jobStatus: JobStatus?
        /// The number of endpoints that were not processed; for example, because of syntax errors.
        public let totalFailures: Int32?
        /// The total number of pieces that must be processed to finish the job. Each piece is an approximately equal portion of the endpoints.
        public let totalPieces: Int32?
        /// The number of endpoints that were processed by the job.
        public let totalProcessed: Int32?
        /// The job type. Will be 'EXPORT'.
        public let `type`: String?

        public init(applicationId: String? = nil, completedPieces: Int32? = nil, completionDate: String? = nil, creationDate: String? = nil, definition: ExportJobResource? = nil, failedPieces: Int32? = nil, failures: [String]? = nil, id: String? = nil, jobStatus: JobStatus? = nil, totalFailures: Int32? = nil, totalPieces: Int32? = nil, totalProcessed: Int32? = nil, type: String? = nil) {
            self.applicationId = applicationId
            self.completedPieces = completedPieces
            self.completionDate = completionDate
            self.creationDate = creationDate
            self.definition = definition
            self.failedPieces = failedPieces
            self.failures = failures
            self.id = id
            self.jobStatus = jobStatus
            self.totalFailures = totalFailures
            self.totalPieces = totalPieces
            self.totalProcessed = totalProcessed
            self.`type` = `type`
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "ApplicationId"
            case completedPieces = "CompletedPieces"
            case completionDate = "CompletionDate"
            case creationDate = "CreationDate"
            case definition = "Definition"
            case failedPieces = "FailedPieces"
            case failures = "Failures"
            case id = "Id"
            case jobStatus = "JobStatus"
            case totalFailures = "TotalFailures"
            case totalPieces = "TotalPieces"
            case totalProcessed = "TotalProcessed"
            case `type` = "Type"
        }
    }

    public struct ExportJobsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Item", required: false, type: .list), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]
        /// A list of export jobs for the application.
        public let item: [ExportJobResponse]?
        /// The string that you use in a subsequent request to get the next page of results in a paginated response.
        public let nextToken: String?

        public init(item: [ExportJobResponse]? = nil, nextToken: String? = nil) {
            self.item = item
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case item = "Item"
            case nextToken = "NextToken"
        }
    }

    public enum FilterType: String, CustomStringConvertible, Codable {
        case system = "SYSTEM"
        case endpoint = "ENDPOINT"
        public var description: String { return self.rawValue }
    }

    public enum Format: String, CustomStringConvertible, Codable {
        case csv = "CSV"
        case json = "JSON"
        public var description: String { return self.rawValue }
    }

    public enum Frequency: String, CustomStringConvertible, Codable {
        case once = "ONCE"
        case hourly = "HOURLY"
        case daily = "DAILY"
        case weekly = "WEEKLY"
        case monthly = "MONTHLY"
        case event = "EVENT"
        public var description: String { return self.rawValue }
    }

    public struct GCMChannelRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApiKey", required: false, type: .string), 
            AWSShapeMember(label: "Enabled", required: false, type: .boolean)
        ]
        /// Platform credential API key from Google.
        public let apiKey: String?
        /// If the channel is enabled for sending messages.
        public let enabled: Bool?

        public init(apiKey: String? = nil, enabled: Bool? = nil) {
            self.apiKey = apiKey
            self.enabled = enabled
        }

        private enum CodingKeys: String, CodingKey {
            case apiKey = "ApiKey"
            case enabled = "Enabled"
        }
    }

    public struct GCMChannelResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", required: false, type: .string), 
            AWSShapeMember(label: "CreationDate", required: false, type: .string), 
            AWSShapeMember(label: "Credential", required: false, type: .string), 
            AWSShapeMember(label: "Enabled", required: false, type: .boolean), 
            AWSShapeMember(label: "HasCredential", required: false, type: .boolean), 
            AWSShapeMember(label: "Id", required: false, type: .string), 
            AWSShapeMember(label: "IsArchived", required: false, type: .boolean), 
            AWSShapeMember(label: "LastModifiedBy", required: false, type: .string), 
            AWSShapeMember(label: "LastModifiedDate", required: false, type: .string), 
            AWSShapeMember(label: "Platform", required: false, type: .string), 
            AWSShapeMember(label: "Version", required: false, type: .integer)
        ]
        /// The ID of the application to which the channel applies.
        public let applicationId: String?
        /// When was this segment created
        public let creationDate: String?
        /// The GCM API key from Google.
        public let credential: String?
        /// If the channel is enabled for sending messages.
        public let enabled: Bool?
        /// Not used. Retained for backwards compatibility.
        public let hasCredential: Bool?
        /// Channel ID. Not used. Present only for backwards compatibility.
        public let id: String?
        /// Is this channel archived
        public let isArchived: Bool?
        /// Who last updated this entry
        public let lastModifiedBy: String?
        /// Last date this was updated
        public let lastModifiedDate: String?
        /// The platform type. Will be GCM
        public let platform: String?
        /// Version of channel
        public let version: Int32?

        public init(applicationId: String? = nil, creationDate: String? = nil, credential: String? = nil, enabled: Bool? = nil, hasCredential: Bool? = nil, id: String? = nil, isArchived: Bool? = nil, lastModifiedBy: String? = nil, lastModifiedDate: String? = nil, platform: String? = nil, version: Int32? = nil) {
            self.applicationId = applicationId
            self.creationDate = creationDate
            self.credential = credential
            self.enabled = enabled
            self.hasCredential = hasCredential
            self.id = id
            self.isArchived = isArchived
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedDate = lastModifiedDate
            self.platform = platform
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "ApplicationId"
            case creationDate = "CreationDate"
            case credential = "Credential"
            case enabled = "Enabled"
            case hasCredential = "HasCredential"
            case id = "Id"
            case isArchived = "IsArchived"
            case lastModifiedBy = "LastModifiedBy"
            case lastModifiedDate = "LastModifiedDate"
            case platform = "Platform"
            case version = "Version"
        }
    }

    public struct GCMMessage: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Action", required: false, type: .enum), 
            AWSShapeMember(label: "Body", required: false, type: .string), 
            AWSShapeMember(label: "CollapseKey", required: false, type: .string), 
            AWSShapeMember(label: "Data", required: false, type: .map), 
            AWSShapeMember(label: "IconReference", required: false, type: .string), 
            AWSShapeMember(label: "ImageIconUrl", required: false, type: .string), 
            AWSShapeMember(label: "ImageUrl", required: false, type: .string), 
            AWSShapeMember(label: "Priority", required: false, type: .string), 
            AWSShapeMember(label: "RawContent", required: false, type: .string), 
            AWSShapeMember(label: "RestrictedPackageName", required: false, type: .string), 
            AWSShapeMember(label: "SilentPush", required: false, type: .boolean), 
            AWSShapeMember(label: "SmallImageIconUrl", required: false, type: .string), 
            AWSShapeMember(label: "Sound", required: false, type: .string), 
            AWSShapeMember(label: "Substitutions", required: false, type: .map), 
            AWSShapeMember(label: "TimeToLive", required: false, type: .integer), 
            AWSShapeMember(label: "Title", required: false, type: .string), 
            AWSShapeMember(label: "Url", required: false, type: .string)
        ]
        /// The action that occurs if the user taps a push notification delivered by the campaign: OPEN_APP - Your app launches, or it becomes the foreground app if it has been sent to the background. This is the default action. DEEP_LINK - Uses deep linking features in iOS and Android to open your app and display a designated user interface within the app. URL - The default mobile browser on the user's device launches and opens a web page at the URL you specify. Possible values include: OPEN_APP | DEEP_LINK | URL
        public let action: Action?
        /// The message body of the notification.
        public let body: String?
        /// This parameter identifies a group of messages (e.g., with collapse_key: "Updates Available") that can be collapsed, so that only the last message gets sent when delivery can be resumed. This is intended to avoid sending too many of the same messages when the device comes back online or becomes active.
        public let collapseKey: String?
        /// The data payload used for a silent push. This payload is added to the notifications' data.pinpoint.jsonBody' object
        public let data: [String: String]?
        /// The icon image name of the asset saved in your application.
        public let iconReference: String?
        /// The URL that points to an image used as the large icon to the notification content view.
        public let imageIconUrl: String?
        /// The URL that points to an image used in the push notification.
        public let imageUrl: String?
        /// The message priority. Amazon Pinpoint uses this value to set the FCM or GCM priority parameter when it sends the message. Accepts the following values:
        /// "Normal" - Messages might be delayed. Delivery is optimized for battery usage on the receiving device. Use normal priority unless immediate delivery is required.
        /// "High" - Messages are sent immediately and might wake a sleeping device.
        /// The equivalent values for APNs messages are "5" and "10". Amazon Pinpoint accepts these values here and converts them.
        /// For more information, see About FCM Messages in the Firebase documentation.
        public let priority: String?
        /// The Raw JSON formatted string to be used as the payload. This value overrides the message.
        public let rawContent: String?
        /// This parameter specifies the package name of the application where the registration tokens must match in order to receive the message.
        public let restrictedPackageName: String?
        /// Indicates if the message should display on the users device. Silent pushes can be used for Remote Configuration and Phone Home use cases.
        public let silentPush: Bool?
        /// The URL that points to an image used as the small icon for the notification which will be used to represent the notification in the status bar and content view
        public let smallImageIconUrl: String?
        /// Indicates a sound to play when the device receives the notification. Supports default, or the filename of a sound resource bundled in the app. Android sound files must reside in /res/raw/
        public let sound: String?
        /// Default message substitutions. Can be overridden by individual address substitutions.
        public let substitutions: [String: [String]]?
        /// The length of time (in seconds) that FCM or GCM stores and attempts to deliver the message. If unspecified, the value defaults to the maximum, which is 2,419,200 seconds (28 days). Amazon Pinpoint uses this value to set the FCM or GCM time_to_live parameter.
        public let timeToLive: Int32?
        /// The message title that displays above the message on the user's device.
        public let title: String?
        /// The URL to open in the user's mobile browser. Used if the value for Action is URL.
        public let url: String?

        public init(action: Action? = nil, body: String? = nil, collapseKey: String? = nil, data: [String: String]? = nil, iconReference: String? = nil, imageIconUrl: String? = nil, imageUrl: String? = nil, priority: String? = nil, rawContent: String? = nil, restrictedPackageName: String? = nil, silentPush: Bool? = nil, smallImageIconUrl: String? = nil, sound: String? = nil, substitutions: [String: [String]]? = nil, timeToLive: Int32? = nil, title: String? = nil, url: String? = nil) {
            self.action = action
            self.body = body
            self.collapseKey = collapseKey
            self.data = data
            self.iconReference = iconReference
            self.imageIconUrl = imageIconUrl
            self.imageUrl = imageUrl
            self.priority = priority
            self.rawContent = rawContent
            self.restrictedPackageName = restrictedPackageName
            self.silentPush = silentPush
            self.smallImageIconUrl = smallImageIconUrl
            self.sound = sound
            self.substitutions = substitutions
            self.timeToLive = timeToLive
            self.title = title
            self.url = url
        }

        private enum CodingKeys: String, CodingKey {
            case action = "Action"
            case body = "Body"
            case collapseKey = "CollapseKey"
            case data = "Data"
            case iconReference = "IconReference"
            case imageIconUrl = "ImageIconUrl"
            case imageUrl = "ImageUrl"
            case priority = "Priority"
            case rawContent = "RawContent"
            case restrictedPackageName = "RestrictedPackageName"
            case silentPush = "SilentPush"
            case smallImageIconUrl = "SmallImageIconUrl"
            case sound = "Sound"
            case substitutions = "Substitutions"
            case timeToLive = "TimeToLive"
            case title = "Title"
            case url = "Url"
        }
    }

    public struct GPSCoordinates: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Latitude", required: false, type: .double), 
            AWSShapeMember(label: "Longitude", required: false, type: .double)
        ]
        /// Latitude
        public let latitude: Double?
        /// Longitude
        public let longitude: Double?

        public init(latitude: Double? = nil, longitude: Double? = nil) {
            self.latitude = latitude
            self.longitude = longitude
        }

        private enum CodingKeys: String, CodingKey {
            case latitude = "Latitude"
            case longitude = "Longitude"
        }
    }

    public struct GPSPointDimension: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Coordinates", required: false, type: .structure), 
            AWSShapeMember(label: "RangeInKilometers", required: false, type: .double)
        ]
        /// Coordinate to measure distance from.
        public let coordinates: GPSCoordinates?
        /// Range in kilometers from the coordinate.
        public let rangeInKilometers: Double?

        public init(coordinates: GPSCoordinates? = nil, rangeInKilometers: Double? = nil) {
            self.coordinates = coordinates
            self.rangeInKilometers = rangeInKilometers
        }

        private enum CodingKeys: String, CodingKey {
            case coordinates = "Coordinates"
            case rangeInKilometers = "RangeInKilometers"
        }
    }

    public struct GetAdmChannelRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let applicationId: String

        public init(applicationId: String) {
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
        }
    }

    public struct GetAdmChannelResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "ADMChannelResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ADMChannelResponse", required: true, type: .structure)
        ]
        public let aDMChannelResponse: ADMChannelResponse

        public init(aDMChannelResponse: ADMChannelResponse) {
            self.aDMChannelResponse = aDMChannelResponse
        }

        private enum CodingKeys: String, CodingKey {
            case aDMChannelResponse = "ADMChannelResponse"
        }
    }

    public struct GetApnsChannelRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let applicationId: String

        public init(applicationId: String) {
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
        }
    }

    public struct GetApnsChannelResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "APNSChannelResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "APNSChannelResponse", required: true, type: .structure)
        ]
        public let aPNSChannelResponse: APNSChannelResponse

        public init(aPNSChannelResponse: APNSChannelResponse) {
            self.aPNSChannelResponse = aPNSChannelResponse
        }

        private enum CodingKeys: String, CodingKey {
            case aPNSChannelResponse = "APNSChannelResponse"
        }
    }

    public struct GetApnsSandboxChannelRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let applicationId: String

        public init(applicationId: String) {
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
        }
    }

    public struct GetApnsSandboxChannelResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "APNSSandboxChannelResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "APNSSandboxChannelResponse", required: true, type: .structure)
        ]
        public let aPNSSandboxChannelResponse: APNSSandboxChannelResponse

        public init(aPNSSandboxChannelResponse: APNSSandboxChannelResponse) {
            self.aPNSSandboxChannelResponse = aPNSSandboxChannelResponse
        }

        private enum CodingKeys: String, CodingKey {
            case aPNSSandboxChannelResponse = "APNSSandboxChannelResponse"
        }
    }

    public struct GetApnsVoipChannelRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let applicationId: String

        public init(applicationId: String) {
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
        }
    }

    public struct GetApnsVoipChannelResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "APNSVoipChannelResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "APNSVoipChannelResponse", required: true, type: .structure)
        ]
        public let aPNSVoipChannelResponse: APNSVoipChannelResponse

        public init(aPNSVoipChannelResponse: APNSVoipChannelResponse) {
            self.aPNSVoipChannelResponse = aPNSVoipChannelResponse
        }

        private enum CodingKeys: String, CodingKey {
            case aPNSVoipChannelResponse = "APNSVoipChannelResponse"
        }
    }

    public struct GetApnsVoipSandboxChannelRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let applicationId: String

        public init(applicationId: String) {
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
        }
    }

    public struct GetApnsVoipSandboxChannelResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "APNSVoipSandboxChannelResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "APNSVoipSandboxChannelResponse", required: true, type: .structure)
        ]
        public let aPNSVoipSandboxChannelResponse: APNSVoipSandboxChannelResponse

        public init(aPNSVoipSandboxChannelResponse: APNSVoipSandboxChannelResponse) {
            self.aPNSVoipSandboxChannelResponse = aPNSVoipSandboxChannelResponse
        }

        private enum CodingKeys: String, CodingKey {
            case aPNSVoipSandboxChannelResponse = "APNSVoipSandboxChannelResponse"
        }
    }

    public struct GetAppRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let applicationId: String

        public init(applicationId: String) {
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
        }
    }

    public struct GetAppResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "ApplicationResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationResponse", required: true, type: .structure)
        ]
        public let applicationResponse: ApplicationResponse

        public init(applicationResponse: ApplicationResponse) {
            self.applicationResponse = applicationResponse
        }

        private enum CodingKeys: String, CodingKey {
            case applicationResponse = "ApplicationResponse"
        }
    }

    public struct GetApplicationSettingsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let applicationId: String

        public init(applicationId: String) {
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
        }
    }

    public struct GetApplicationSettingsResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "ApplicationSettingsResource"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationSettingsResource", required: true, type: .structure)
        ]
        public let applicationSettingsResource: ApplicationSettingsResource

        public init(applicationSettingsResource: ApplicationSettingsResource) {
            self.applicationSettingsResource = applicationSettingsResource
        }

        private enum CodingKeys: String, CodingKey {
            case applicationSettingsResource = "ApplicationSettingsResource"
        }
    }

    public struct GetAppsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "PageSize", location: .querystring(locationName: "page-size"), required: false, type: .string), 
            AWSShapeMember(label: "Token", location: .querystring(locationName: "token"), required: false, type: .string)
        ]
        public let pageSize: String?
        public let token: String?

        public init(pageSize: String? = nil, token: String? = nil) {
            self.pageSize = pageSize
            self.token = token
        }

        private enum CodingKeys: String, CodingKey {
            case pageSize = "page-size"
            case token = "token"
        }
    }

    public struct GetAppsResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "ApplicationsResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationsResponse", required: true, type: .structure)
        ]
        public let applicationsResponse: ApplicationsResponse

        public init(applicationsResponse: ApplicationsResponse) {
            self.applicationsResponse = applicationsResponse
        }

        private enum CodingKeys: String, CodingKey {
            case applicationsResponse = "ApplicationsResponse"
        }
    }

    public struct GetBaiduChannelRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let applicationId: String

        public init(applicationId: String) {
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
        }
    }

    public struct GetBaiduChannelResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "BaiduChannelResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "BaiduChannelResponse", required: true, type: .structure)
        ]
        public let baiduChannelResponse: BaiduChannelResponse

        public init(baiduChannelResponse: BaiduChannelResponse) {
            self.baiduChannelResponse = baiduChannelResponse
        }

        private enum CodingKeys: String, CodingKey {
            case baiduChannelResponse = "BaiduChannelResponse"
        }
    }

    public struct GetCampaignActivitiesRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string), 
            AWSShapeMember(label: "CampaignId", location: .uri(locationName: "campaign-id"), required: true, type: .string), 
            AWSShapeMember(label: "PageSize", location: .querystring(locationName: "page-size"), required: false, type: .string), 
            AWSShapeMember(label: "Token", location: .querystring(locationName: "token"), required: false, type: .string)
        ]
        public let applicationId: String
        public let campaignId: String
        public let pageSize: String?
        public let token: String?

        public init(applicationId: String, campaignId: String, pageSize: String? = nil, token: String? = nil) {
            self.applicationId = applicationId
            self.campaignId = campaignId
            self.pageSize = pageSize
            self.token = token
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
            case campaignId = "campaign-id"
            case pageSize = "page-size"
            case token = "token"
        }
    }

    public struct GetCampaignActivitiesResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "ActivitiesResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ActivitiesResponse", required: true, type: .structure)
        ]
        public let activitiesResponse: ActivitiesResponse

        public init(activitiesResponse: ActivitiesResponse) {
            self.activitiesResponse = activitiesResponse
        }

        private enum CodingKeys: String, CodingKey {
            case activitiesResponse = "ActivitiesResponse"
        }
    }

    public struct GetCampaignRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string), 
            AWSShapeMember(label: "CampaignId", location: .uri(locationName: "campaign-id"), required: true, type: .string)
        ]
        public let applicationId: String
        public let campaignId: String

        public init(applicationId: String, campaignId: String) {
            self.applicationId = applicationId
            self.campaignId = campaignId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
            case campaignId = "campaign-id"
        }
    }

    public struct GetCampaignResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "CampaignResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CampaignResponse", required: true, type: .structure)
        ]
        public let campaignResponse: CampaignResponse

        public init(campaignResponse: CampaignResponse) {
            self.campaignResponse = campaignResponse
        }

        private enum CodingKeys: String, CodingKey {
            case campaignResponse = "CampaignResponse"
        }
    }

    public struct GetCampaignVersionRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string), 
            AWSShapeMember(label: "CampaignId", location: .uri(locationName: "campaign-id"), required: true, type: .string), 
            AWSShapeMember(label: "Version", location: .uri(locationName: "version"), required: true, type: .string)
        ]
        public let applicationId: String
        public let campaignId: String
        public let version: String

        public init(applicationId: String, campaignId: String, version: String) {
            self.applicationId = applicationId
            self.campaignId = campaignId
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
            case campaignId = "campaign-id"
            case version = "version"
        }
    }

    public struct GetCampaignVersionResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "CampaignResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CampaignResponse", required: true, type: .structure)
        ]
        public let campaignResponse: CampaignResponse

        public init(campaignResponse: CampaignResponse) {
            self.campaignResponse = campaignResponse
        }

        private enum CodingKeys: String, CodingKey {
            case campaignResponse = "CampaignResponse"
        }
    }

    public struct GetCampaignVersionsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string), 
            AWSShapeMember(label: "CampaignId", location: .uri(locationName: "campaign-id"), required: true, type: .string), 
            AWSShapeMember(label: "PageSize", location: .querystring(locationName: "page-size"), required: false, type: .string), 
            AWSShapeMember(label: "Token", location: .querystring(locationName: "token"), required: false, type: .string)
        ]
        public let applicationId: String
        public let campaignId: String
        public let pageSize: String?
        public let token: String?

        public init(applicationId: String, campaignId: String, pageSize: String? = nil, token: String? = nil) {
            self.applicationId = applicationId
            self.campaignId = campaignId
            self.pageSize = pageSize
            self.token = token
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
            case campaignId = "campaign-id"
            case pageSize = "page-size"
            case token = "token"
        }
    }

    public struct GetCampaignVersionsResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "CampaignsResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CampaignsResponse", required: true, type: .structure)
        ]
        public let campaignsResponse: CampaignsResponse

        public init(campaignsResponse: CampaignsResponse) {
            self.campaignsResponse = campaignsResponse
        }

        private enum CodingKeys: String, CodingKey {
            case campaignsResponse = "CampaignsResponse"
        }
    }

    public struct GetCampaignsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string), 
            AWSShapeMember(label: "PageSize", location: .querystring(locationName: "page-size"), required: false, type: .string), 
            AWSShapeMember(label: "Token", location: .querystring(locationName: "token"), required: false, type: .string)
        ]
        public let applicationId: String
        public let pageSize: String?
        public let token: String?

        public init(applicationId: String, pageSize: String? = nil, token: String? = nil) {
            self.applicationId = applicationId
            self.pageSize = pageSize
            self.token = token
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
            case pageSize = "page-size"
            case token = "token"
        }
    }

    public struct GetCampaignsResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "CampaignsResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CampaignsResponse", required: true, type: .structure)
        ]
        public let campaignsResponse: CampaignsResponse

        public init(campaignsResponse: CampaignsResponse) {
            self.campaignsResponse = campaignsResponse
        }

        private enum CodingKeys: String, CodingKey {
            case campaignsResponse = "CampaignsResponse"
        }
    }

    public struct GetChannelsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let applicationId: String

        public init(applicationId: String) {
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
        }
    }

    public struct GetChannelsResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "ChannelsResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ChannelsResponse", required: true, type: .structure)
        ]
        public let channelsResponse: ChannelsResponse

        public init(channelsResponse: ChannelsResponse) {
            self.channelsResponse = channelsResponse
        }

        private enum CodingKeys: String, CodingKey {
            case channelsResponse = "ChannelsResponse"
        }
    }

    public struct GetEmailChannelRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let applicationId: String

        public init(applicationId: String) {
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
        }
    }

    public struct GetEmailChannelResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "EmailChannelResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "EmailChannelResponse", required: true, type: .structure)
        ]
        public let emailChannelResponse: EmailChannelResponse

        public init(emailChannelResponse: EmailChannelResponse) {
            self.emailChannelResponse = emailChannelResponse
        }

        private enum CodingKeys: String, CodingKey {
            case emailChannelResponse = "EmailChannelResponse"
        }
    }

    public struct GetEndpointRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string), 
            AWSShapeMember(label: "EndpointId", location: .uri(locationName: "endpoint-id"), required: true, type: .string)
        ]
        public let applicationId: String
        public let endpointId: String

        public init(applicationId: String, endpointId: String) {
            self.applicationId = applicationId
            self.endpointId = endpointId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
            case endpointId = "endpoint-id"
        }
    }

    public struct GetEndpointResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "EndpointResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "EndpointResponse", required: true, type: .structure)
        ]
        public let endpointResponse: EndpointResponse

        public init(endpointResponse: EndpointResponse) {
            self.endpointResponse = endpointResponse
        }

        private enum CodingKeys: String, CodingKey {
            case endpointResponse = "EndpointResponse"
        }
    }

    public struct GetEventStreamRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let applicationId: String

        public init(applicationId: String) {
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
        }
    }

    public struct GetEventStreamResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "EventStream"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "EventStream", required: true, type: .structure)
        ]
        public let eventStream: EventStream

        public init(eventStream: EventStream) {
            self.eventStream = eventStream
        }

        private enum CodingKeys: String, CodingKey {
            case eventStream = "EventStream"
        }
    }

    public struct GetExportJobRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string), 
            AWSShapeMember(label: "JobId", location: .uri(locationName: "job-id"), required: true, type: .string)
        ]
        public let applicationId: String
        public let jobId: String

        public init(applicationId: String, jobId: String) {
            self.applicationId = applicationId
            self.jobId = jobId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
            case jobId = "job-id"
        }
    }

    public struct GetExportJobResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "ExportJobResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ExportJobResponse", required: true, type: .structure)
        ]
        public let exportJobResponse: ExportJobResponse

        public init(exportJobResponse: ExportJobResponse) {
            self.exportJobResponse = exportJobResponse
        }

        private enum CodingKeys: String, CodingKey {
            case exportJobResponse = "ExportJobResponse"
        }
    }

    public struct GetExportJobsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string), 
            AWSShapeMember(label: "PageSize", location: .querystring(locationName: "page-size"), required: false, type: .string), 
            AWSShapeMember(label: "Token", location: .querystring(locationName: "token"), required: false, type: .string)
        ]
        public let applicationId: String
        public let pageSize: String?
        public let token: String?

        public init(applicationId: String, pageSize: String? = nil, token: String? = nil) {
            self.applicationId = applicationId
            self.pageSize = pageSize
            self.token = token
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
            case pageSize = "page-size"
            case token = "token"
        }
    }

    public struct GetExportJobsResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "ExportJobsResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ExportJobsResponse", required: true, type: .structure)
        ]
        public let exportJobsResponse: ExportJobsResponse

        public init(exportJobsResponse: ExportJobsResponse) {
            self.exportJobsResponse = exportJobsResponse
        }

        private enum CodingKeys: String, CodingKey {
            case exportJobsResponse = "ExportJobsResponse"
        }
    }

    public struct GetGcmChannelRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let applicationId: String

        public init(applicationId: String) {
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
        }
    }

    public struct GetGcmChannelResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "GCMChannelResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "GCMChannelResponse", required: true, type: .structure)
        ]
        public let gCMChannelResponse: GCMChannelResponse

        public init(gCMChannelResponse: GCMChannelResponse) {
            self.gCMChannelResponse = gCMChannelResponse
        }

        private enum CodingKeys: String, CodingKey {
            case gCMChannelResponse = "GCMChannelResponse"
        }
    }

    public struct GetImportJobRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string), 
            AWSShapeMember(label: "JobId", location: .uri(locationName: "job-id"), required: true, type: .string)
        ]
        public let applicationId: String
        public let jobId: String

        public init(applicationId: String, jobId: String) {
            self.applicationId = applicationId
            self.jobId = jobId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
            case jobId = "job-id"
        }
    }

    public struct GetImportJobResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "ImportJobResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ImportJobResponse", required: true, type: .structure)
        ]
        public let importJobResponse: ImportJobResponse

        public init(importJobResponse: ImportJobResponse) {
            self.importJobResponse = importJobResponse
        }

        private enum CodingKeys: String, CodingKey {
            case importJobResponse = "ImportJobResponse"
        }
    }

    public struct GetImportJobsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string), 
            AWSShapeMember(label: "PageSize", location: .querystring(locationName: "page-size"), required: false, type: .string), 
            AWSShapeMember(label: "Token", location: .querystring(locationName: "token"), required: false, type: .string)
        ]
        public let applicationId: String
        public let pageSize: String?
        public let token: String?

        public init(applicationId: String, pageSize: String? = nil, token: String? = nil) {
            self.applicationId = applicationId
            self.pageSize = pageSize
            self.token = token
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
            case pageSize = "page-size"
            case token = "token"
        }
    }

    public struct GetImportJobsResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "ImportJobsResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ImportJobsResponse", required: true, type: .structure)
        ]
        public let importJobsResponse: ImportJobsResponse

        public init(importJobsResponse: ImportJobsResponse) {
            self.importJobsResponse = importJobsResponse
        }

        private enum CodingKeys: String, CodingKey {
            case importJobsResponse = "ImportJobsResponse"
        }
    }

    public struct GetSegmentExportJobsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string), 
            AWSShapeMember(label: "PageSize", location: .querystring(locationName: "page-size"), required: false, type: .string), 
            AWSShapeMember(label: "SegmentId", location: .uri(locationName: "segment-id"), required: true, type: .string), 
            AWSShapeMember(label: "Token", location: .querystring(locationName: "token"), required: false, type: .string)
        ]
        public let applicationId: String
        public let pageSize: String?
        public let segmentId: String
        public let token: String?

        public init(applicationId: String, pageSize: String? = nil, segmentId: String, token: String? = nil) {
            self.applicationId = applicationId
            self.pageSize = pageSize
            self.segmentId = segmentId
            self.token = token
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
            case pageSize = "page-size"
            case segmentId = "segment-id"
            case token = "token"
        }
    }

    public struct GetSegmentExportJobsResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "ExportJobsResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ExportJobsResponse", required: true, type: .structure)
        ]
        public let exportJobsResponse: ExportJobsResponse

        public init(exportJobsResponse: ExportJobsResponse) {
            self.exportJobsResponse = exportJobsResponse
        }

        private enum CodingKeys: String, CodingKey {
            case exportJobsResponse = "ExportJobsResponse"
        }
    }

    public struct GetSegmentImportJobsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string), 
            AWSShapeMember(label: "PageSize", location: .querystring(locationName: "page-size"), required: false, type: .string), 
            AWSShapeMember(label: "SegmentId", location: .uri(locationName: "segment-id"), required: true, type: .string), 
            AWSShapeMember(label: "Token", location: .querystring(locationName: "token"), required: false, type: .string)
        ]
        public let applicationId: String
        public let pageSize: String?
        public let segmentId: String
        public let token: String?

        public init(applicationId: String, pageSize: String? = nil, segmentId: String, token: String? = nil) {
            self.applicationId = applicationId
            self.pageSize = pageSize
            self.segmentId = segmentId
            self.token = token
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
            case pageSize = "page-size"
            case segmentId = "segment-id"
            case token = "token"
        }
    }

    public struct GetSegmentImportJobsResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "ImportJobsResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ImportJobsResponse", required: true, type: .structure)
        ]
        public let importJobsResponse: ImportJobsResponse

        public init(importJobsResponse: ImportJobsResponse) {
            self.importJobsResponse = importJobsResponse
        }

        private enum CodingKeys: String, CodingKey {
            case importJobsResponse = "ImportJobsResponse"
        }
    }

    public struct GetSegmentRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string), 
            AWSShapeMember(label: "SegmentId", location: .uri(locationName: "segment-id"), required: true, type: .string)
        ]
        public let applicationId: String
        public let segmentId: String

        public init(applicationId: String, segmentId: String) {
            self.applicationId = applicationId
            self.segmentId = segmentId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
            case segmentId = "segment-id"
        }
    }

    public struct GetSegmentResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "SegmentResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SegmentResponse", required: true, type: .structure)
        ]
        public let segmentResponse: SegmentResponse

        public init(segmentResponse: SegmentResponse) {
            self.segmentResponse = segmentResponse
        }

        private enum CodingKeys: String, CodingKey {
            case segmentResponse = "SegmentResponse"
        }
    }

    public struct GetSegmentVersionRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string), 
            AWSShapeMember(label: "SegmentId", location: .uri(locationName: "segment-id"), required: true, type: .string), 
            AWSShapeMember(label: "Version", location: .uri(locationName: "version"), required: true, type: .string)
        ]
        public let applicationId: String
        public let segmentId: String
        public let version: String

        public init(applicationId: String, segmentId: String, version: String) {
            self.applicationId = applicationId
            self.segmentId = segmentId
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
            case segmentId = "segment-id"
            case version = "version"
        }
    }

    public struct GetSegmentVersionResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "SegmentResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SegmentResponse", required: true, type: .structure)
        ]
        public let segmentResponse: SegmentResponse

        public init(segmentResponse: SegmentResponse) {
            self.segmentResponse = segmentResponse
        }

        private enum CodingKeys: String, CodingKey {
            case segmentResponse = "SegmentResponse"
        }
    }

    public struct GetSegmentVersionsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string), 
            AWSShapeMember(label: "PageSize", location: .querystring(locationName: "page-size"), required: false, type: .string), 
            AWSShapeMember(label: "SegmentId", location: .uri(locationName: "segment-id"), required: true, type: .string), 
            AWSShapeMember(label: "Token", location: .querystring(locationName: "token"), required: false, type: .string)
        ]
        public let applicationId: String
        public let pageSize: String?
        public let segmentId: String
        public let token: String?

        public init(applicationId: String, pageSize: String? = nil, segmentId: String, token: String? = nil) {
            self.applicationId = applicationId
            self.pageSize = pageSize
            self.segmentId = segmentId
            self.token = token
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
            case pageSize = "page-size"
            case segmentId = "segment-id"
            case token = "token"
        }
    }

    public struct GetSegmentVersionsResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "SegmentsResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SegmentsResponse", required: true, type: .structure)
        ]
        public let segmentsResponse: SegmentsResponse

        public init(segmentsResponse: SegmentsResponse) {
            self.segmentsResponse = segmentsResponse
        }

        private enum CodingKeys: String, CodingKey {
            case segmentsResponse = "SegmentsResponse"
        }
    }

    public struct GetSegmentsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string), 
            AWSShapeMember(label: "PageSize", location: .querystring(locationName: "page-size"), required: false, type: .string), 
            AWSShapeMember(label: "Token", location: .querystring(locationName: "token"), required: false, type: .string)
        ]
        public let applicationId: String
        public let pageSize: String?
        public let token: String?

        public init(applicationId: String, pageSize: String? = nil, token: String? = nil) {
            self.applicationId = applicationId
            self.pageSize = pageSize
            self.token = token
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
            case pageSize = "page-size"
            case token = "token"
        }
    }

    public struct GetSegmentsResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "SegmentsResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SegmentsResponse", required: true, type: .structure)
        ]
        public let segmentsResponse: SegmentsResponse

        public init(segmentsResponse: SegmentsResponse) {
            self.segmentsResponse = segmentsResponse
        }

        private enum CodingKeys: String, CodingKey {
            case segmentsResponse = "SegmentsResponse"
        }
    }

    public struct GetSmsChannelRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let applicationId: String

        public init(applicationId: String) {
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
        }
    }

    public struct GetSmsChannelResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "SMSChannelResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SMSChannelResponse", required: true, type: .structure)
        ]
        public let sMSChannelResponse: SMSChannelResponse

        public init(sMSChannelResponse: SMSChannelResponse) {
            self.sMSChannelResponse = sMSChannelResponse
        }

        private enum CodingKeys: String, CodingKey {
            case sMSChannelResponse = "SMSChannelResponse"
        }
    }

    public struct GetUserEndpointsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string), 
            AWSShapeMember(label: "UserId", location: .uri(locationName: "user-id"), required: true, type: .string)
        ]
        public let applicationId: String
        public let userId: String

        public init(applicationId: String, userId: String) {
            self.applicationId = applicationId
            self.userId = userId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
            case userId = "user-id"
        }
    }

    public struct GetUserEndpointsResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "EndpointsResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "EndpointsResponse", required: true, type: .structure)
        ]
        public let endpointsResponse: EndpointsResponse

        public init(endpointsResponse: EndpointsResponse) {
            self.endpointsResponse = endpointsResponse
        }

        private enum CodingKeys: String, CodingKey {
            case endpointsResponse = "EndpointsResponse"
        }
    }

    public struct GetVoiceChannelRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let applicationId: String

        public init(applicationId: String) {
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
        }
    }

    public struct GetVoiceChannelResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "VoiceChannelResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "VoiceChannelResponse", required: true, type: .structure)
        ]
        public let voiceChannelResponse: VoiceChannelResponse

        public init(voiceChannelResponse: VoiceChannelResponse) {
            self.voiceChannelResponse = voiceChannelResponse
        }

        private enum CodingKeys: String, CodingKey {
            case voiceChannelResponse = "VoiceChannelResponse"
        }
    }

    public struct ImportJobRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DefineSegment", required: false, type: .boolean), 
            AWSShapeMember(label: "ExternalId", required: false, type: .string), 
            AWSShapeMember(label: "Format", required: false, type: .enum), 
            AWSShapeMember(label: "RegisterEndpoints", required: false, type: .boolean), 
            AWSShapeMember(label: "RoleArn", required: false, type: .string), 
            AWSShapeMember(label: "S3Url", required: false, type: .string), 
            AWSShapeMember(label: "SegmentId", required: false, type: .string), 
            AWSShapeMember(label: "SegmentName", required: false, type: .string)
        ]
        /// Sets whether the endpoints create a segment when they are imported.
        public let defineSegment: Bool?
        /// (Deprecated) Your AWS account ID, which you assigned to the ExternalID key in an IAM trust policy. Used by Amazon Pinpoint to assume an IAM role. This requirement is removed, and external IDs are not recommended for IAM roles assumed by Amazon Pinpoint.
        public let externalId: String?
        /// The format of the files that contain the endpoint definitions.
        /// Valid values: CSV, JSON
        public let format: Format?
        /// Sets whether the endpoints are registered with Amazon Pinpoint when they are imported.
        public let registerEndpoints: Bool?
        /// The Amazon Resource Name (ARN) of an IAM role that grants Amazon Pinpoint access to the Amazon S3 location that contains the endpoints to import.
        public let roleArn: String?
        /// The URL of the S3 bucket that contains the segment information to import. The location can be a folder or a single file. The URL should use the following format: s3://bucket-name/folder-name/file-name
        /// Amazon Pinpoint imports endpoints from this location and any subfolders it contains.
        public let s3Url: String?
        /// The ID of the segment to update if the import job is meant to update an existing segment.
        public let segmentId: String?
        /// A custom name for the segment created by the import job. Use if DefineSegment is true.
        public let segmentName: String?

        public init(defineSegment: Bool? = nil, externalId: String? = nil, format: Format? = nil, registerEndpoints: Bool? = nil, roleArn: String? = nil, s3Url: String? = nil, segmentId: String? = nil, segmentName: String? = nil) {
            self.defineSegment = defineSegment
            self.externalId = externalId
            self.format = format
            self.registerEndpoints = registerEndpoints
            self.roleArn = roleArn
            self.s3Url = s3Url
            self.segmentId = segmentId
            self.segmentName = segmentName
        }

        private enum CodingKeys: String, CodingKey {
            case defineSegment = "DefineSegment"
            case externalId = "ExternalId"
            case format = "Format"
            case registerEndpoints = "RegisterEndpoints"
            case roleArn = "RoleArn"
            case s3Url = "S3Url"
            case segmentId = "SegmentId"
            case segmentName = "SegmentName"
        }
    }

    public struct ImportJobResource: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DefineSegment", required: false, type: .boolean), 
            AWSShapeMember(label: "ExternalId", required: false, type: .string), 
            AWSShapeMember(label: "Format", required: false, type: .enum), 
            AWSShapeMember(label: "RegisterEndpoints", required: false, type: .boolean), 
            AWSShapeMember(label: "RoleArn", required: false, type: .string), 
            AWSShapeMember(label: "S3Url", required: false, type: .string), 
            AWSShapeMember(label: "SegmentId", required: false, type: .string), 
            AWSShapeMember(label: "SegmentName", required: false, type: .string)
        ]
        /// Sets whether the endpoints create a segment when they are imported.
        public let defineSegment: Bool?
        /// (Deprecated) Your AWS account ID, which you assigned to the ExternalID key in an IAM trust policy. Used by Amazon Pinpoint to assume an IAM role. This requirement is removed, and external IDs are not recommended for IAM roles assumed by Amazon Pinpoint.
        public let externalId: String?
        /// The format of the files that contain the endpoint definitions.
        /// Valid values: CSV, JSON
        public let format: Format?
        /// Sets whether the endpoints are registered with Amazon Pinpoint when they are imported.
        public let registerEndpoints: Bool?
        /// The Amazon Resource Name (ARN) of an IAM role that grants Amazon Pinpoint access to the Amazon S3 location that contains the endpoints to import.
        public let roleArn: String?
        /// The URL of the S3 bucket that contains the segment information to import. The location can be a folder or a single file. The URL should use the following format: s3://bucket-name/folder-name/file-name
        /// Amazon Pinpoint imports endpoints from this location and any subfolders it contains.
        public let s3Url: String?
        /// The ID of the segment to update if the import job is meant to update an existing segment.
        public let segmentId: String?
        /// A custom name for the segment created by the import job. Use if DefineSegment is true.
        public let segmentName: String?

        public init(defineSegment: Bool? = nil, externalId: String? = nil, format: Format? = nil, registerEndpoints: Bool? = nil, roleArn: String? = nil, s3Url: String? = nil, segmentId: String? = nil, segmentName: String? = nil) {
            self.defineSegment = defineSegment
            self.externalId = externalId
            self.format = format
            self.registerEndpoints = registerEndpoints
            self.roleArn = roleArn
            self.s3Url = s3Url
            self.segmentId = segmentId
            self.segmentName = segmentName
        }

        private enum CodingKeys: String, CodingKey {
            case defineSegment = "DefineSegment"
            case externalId = "ExternalId"
            case format = "Format"
            case registerEndpoints = "RegisterEndpoints"
            case roleArn = "RoleArn"
            case s3Url = "S3Url"
            case segmentId = "SegmentId"
            case segmentName = "SegmentName"
        }
    }

    public struct ImportJobResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", required: false, type: .string), 
            AWSShapeMember(label: "CompletedPieces", required: false, type: .integer), 
            AWSShapeMember(label: "CompletionDate", required: false, type: .string), 
            AWSShapeMember(label: "CreationDate", required: false, type: .string), 
            AWSShapeMember(label: "Definition", required: false, type: .structure), 
            AWSShapeMember(label: "FailedPieces", required: false, type: .integer), 
            AWSShapeMember(label: "Failures", required: false, type: .list), 
            AWSShapeMember(label: "Id", required: false, type: .string), 
            AWSShapeMember(label: "JobStatus", required: false, type: .enum), 
            AWSShapeMember(label: "TotalFailures", required: false, type: .integer), 
            AWSShapeMember(label: "TotalPieces", required: false, type: .integer), 
            AWSShapeMember(label: "TotalProcessed", required: false, type: .integer), 
            AWSShapeMember(label: "Type", required: false, type: .string)
        ]
        /// The unique ID of the application to which the import job applies.
        public let applicationId: String?
        /// The number of pieces that have successfully imported as of the time of the request.
        public let completedPieces: Int32?
        /// The date the import job completed in ISO 8601 format.
        public let completionDate: String?
        /// The date the import job was created in ISO 8601 format.
        public let creationDate: String?
        /// The import job settings.
        public let definition: ImportJobResource?
        /// The number of pieces that have failed to import as of the time of the request.
        public let failedPieces: Int32?
        /// Provides up to 100 of the first failed entries for the job, if any exist.
        public let failures: [String]?
        /// The unique ID of the import job.
        public let id: String?
        /// The status of the import job.
        /// Valid values: CREATED, INITIALIZING, PROCESSING, COMPLETING, COMPLETED, FAILING, FAILED
        /// The job status is FAILED if one or more pieces failed to import.
        public let jobStatus: JobStatus?
        /// The number of endpoints that failed to import; for example, because of syntax errors.
        public let totalFailures: Int32?
        /// The total number of pieces that must be imported to finish the job. Each piece is an approximately equal portion of the endpoints to import.
        public let totalPieces: Int32?
        /// The number of endpoints that were processed by the import job.
        public let totalProcessed: Int32?
        /// The job type. Will be Import.
        public let `type`: String?

        public init(applicationId: String? = nil, completedPieces: Int32? = nil, completionDate: String? = nil, creationDate: String? = nil, definition: ImportJobResource? = nil, failedPieces: Int32? = nil, failures: [String]? = nil, id: String? = nil, jobStatus: JobStatus? = nil, totalFailures: Int32? = nil, totalPieces: Int32? = nil, totalProcessed: Int32? = nil, type: String? = nil) {
            self.applicationId = applicationId
            self.completedPieces = completedPieces
            self.completionDate = completionDate
            self.creationDate = creationDate
            self.definition = definition
            self.failedPieces = failedPieces
            self.failures = failures
            self.id = id
            self.jobStatus = jobStatus
            self.totalFailures = totalFailures
            self.totalPieces = totalPieces
            self.totalProcessed = totalProcessed
            self.`type` = `type`
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "ApplicationId"
            case completedPieces = "CompletedPieces"
            case completionDate = "CompletionDate"
            case creationDate = "CreationDate"
            case definition = "Definition"
            case failedPieces = "FailedPieces"
            case failures = "Failures"
            case id = "Id"
            case jobStatus = "JobStatus"
            case totalFailures = "TotalFailures"
            case totalPieces = "TotalPieces"
            case totalProcessed = "TotalProcessed"
            case `type` = "Type"
        }
    }

    public struct ImportJobsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Item", required: false, type: .list), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]
        /// A list of import jobs for the application.
        public let item: [ImportJobResponse]?
        /// The string that you use in a subsequent request to get the next page of results in a paginated response.
        public let nextToken: String?

        public init(item: [ImportJobResponse]? = nil, nextToken: String? = nil) {
            self.item = item
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case item = "Item"
            case nextToken = "NextToken"
        }
    }

    public enum Include: String, CustomStringConvertible, Codable {
        case all = "ALL"
        case any = "ANY"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public struct ItemResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "EndpointItemResponse", required: false, type: .structure), 
            AWSShapeMember(label: "EventsItemResponse", required: false, type: .map)
        ]
        /// The response received after the endpoint was accepted.
        public let endpointItemResponse: EndpointItemResponse?
        /// A multipart response object that contains a key and value for each event ID in the request. In each object, the event ID is the key, and an EventItemResponse object is the value.
        public let eventsItemResponse: [String: EventItemResponse]?

        public init(endpointItemResponse: EndpointItemResponse? = nil, eventsItemResponse: [String: EventItemResponse]? = nil) {
            self.endpointItemResponse = endpointItemResponse
            self.eventsItemResponse = eventsItemResponse
        }

        private enum CodingKeys: String, CodingKey {
            case endpointItemResponse = "EndpointItemResponse"
            case eventsItemResponse = "EventsItemResponse"
        }
    }

    public enum JobStatus: String, CustomStringConvertible, Codable {
        case created = "CREATED"
        case initializing = "INITIALIZING"
        case processing = "PROCESSING"
        case completing = "COMPLETING"
        case completed = "COMPLETED"
        case failing = "FAILING"
        case failed = "FAILED"
        public var description: String { return self.rawValue }
    }

    public struct ListTagsForResourceRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ResourceArn", location: .uri(locationName: "resource-arn"), required: true, type: .string)
        ]
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "resource-arn"
        }
    }

    public struct ListTagsForResourceResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "TagsModel"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "TagsModel", required: true, type: .structure)
        ]
        public let tagsModel: TagsModel

        public init(tagsModel: TagsModel) {
            self.tagsModel = tagsModel
        }

        private enum CodingKeys: String, CodingKey {
            case tagsModel = "TagsModel"
        }
    }

    public struct Message: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Action", required: false, type: .enum), 
            AWSShapeMember(label: "Body", required: false, type: .string), 
            AWSShapeMember(label: "ImageIconUrl", required: false, type: .string), 
            AWSShapeMember(label: "ImageSmallIconUrl", required: false, type: .string), 
            AWSShapeMember(label: "ImageUrl", required: false, type: .string), 
            AWSShapeMember(label: "JsonBody", required: false, type: .string), 
            AWSShapeMember(label: "MediaUrl", required: false, type: .string), 
            AWSShapeMember(label: "RawContent", required: false, type: .string), 
            AWSShapeMember(label: "SilentPush", required: false, type: .boolean), 
            AWSShapeMember(label: "TimeToLive", required: false, type: .integer), 
            AWSShapeMember(label: "Title", required: false, type: .string), 
            AWSShapeMember(label: "Url", required: false, type: .string)
        ]
        /// The action that occurs if the user taps a push notification delivered by the campaign:
        /// OPEN_APP - Your app launches, or it becomes the foreground app if it has been sent to the background. This is the default action.
        /// DEEP_LINK - Uses deep linking features in iOS and Android to open your app and display a designated user interface within the app.
        /// URL - The default mobile browser on the user's device launches and opens a web page at the URL you specify.
        public let action: Action?
        /// The message body. Can include up to 140 characters.
        public let body: String?
        /// The URL that points to the icon image for the push notification icon, for example, the app icon.
        public let imageIconUrl: String?
        /// The URL that points to the small icon image for the push notification icon, for example, the app icon.
        public let imageSmallIconUrl: String?
        /// The URL that points to an image used in the push notification.
        public let imageUrl: String?
        /// The JSON payload used for a silent push.
        public let jsonBody: String?
        /// A URL that refers to the location of an image or video that you want to display in the push notification.
        public let mediaUrl: String?
        /// The Raw JSON formatted string to be used as the payload. This value overrides the message.
        public let rawContent: String?
        /// Indicates if the message should display on the users device.
        /// Silent pushes can be used for Remote Configuration and Phone Home use cases. 
        public let silentPush: Bool?
        /// This parameter specifies how long (in seconds) the message should be kept if the service is unable to deliver the notification the first time. If the value is 0, it treats the notification as if it expires immediately and does not store the notification or attempt to redeliver it. This value is converted to the expiration field when sent to the service. It only applies to APNs and GCM
        public let timeToLive: Int32?
        /// The message title that displays above the message on the user's device.
        public let title: String?
        /// The URL to open in the user's mobile browser. Used if the value for Action is URL.
        public let url: String?

        public init(action: Action? = nil, body: String? = nil, imageIconUrl: String? = nil, imageSmallIconUrl: String? = nil, imageUrl: String? = nil, jsonBody: String? = nil, mediaUrl: String? = nil, rawContent: String? = nil, silentPush: Bool? = nil, timeToLive: Int32? = nil, title: String? = nil, url: String? = nil) {
            self.action = action
            self.body = body
            self.imageIconUrl = imageIconUrl
            self.imageSmallIconUrl = imageSmallIconUrl
            self.imageUrl = imageUrl
            self.jsonBody = jsonBody
            self.mediaUrl = mediaUrl
            self.rawContent = rawContent
            self.silentPush = silentPush
            self.timeToLive = timeToLive
            self.title = title
            self.url = url
        }

        private enum CodingKeys: String, CodingKey {
            case action = "Action"
            case body = "Body"
            case imageIconUrl = "ImageIconUrl"
            case imageSmallIconUrl = "ImageSmallIconUrl"
            case imageUrl = "ImageUrl"
            case jsonBody = "JsonBody"
            case mediaUrl = "MediaUrl"
            case rawContent = "RawContent"
            case silentPush = "SilentPush"
            case timeToLive = "TimeToLive"
            case title = "Title"
            case url = "Url"
        }
    }

    public struct MessageBody: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Message", required: false, type: .string), 
            AWSShapeMember(label: "RequestID", required: false, type: .string)
        ]
        /// The error message that's returned from the API.
        public let message: String?
        /// The unique message body ID.
        public let requestID: String?

        public init(message: String? = nil, requestID: String? = nil) {
            self.message = message
            self.requestID = requestID
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case requestID = "RequestID"
        }
    }

    public struct MessageConfiguration: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ADMMessage", required: false, type: .structure), 
            AWSShapeMember(label: "APNSMessage", required: false, type: .structure), 
            AWSShapeMember(label: "BaiduMessage", required: false, type: .structure), 
            AWSShapeMember(label: "DefaultMessage", required: false, type: .structure), 
            AWSShapeMember(label: "EmailMessage", required: false, type: .structure), 
            AWSShapeMember(label: "GCMMessage", required: false, type: .structure), 
            AWSShapeMember(label: "SMSMessage", required: false, type: .structure)
        ]
        /// The message that the campaign delivers to ADM channels. Overrides the default message.
        public let aDMMessage: Message?
        /// The message that the campaign delivers to APNS channels. Overrides the default message.
        public let aPNSMessage: Message?
        /// The message that the campaign delivers to Baidu channels. Overrides the default message.
        public let baiduMessage: Message?
        /// The default message for all channels.
        public let defaultMessage: Message?
        /// The email message configuration.
        public let emailMessage: CampaignEmailMessage?
        /// The message that the campaign delivers to GCM channels. Overrides the default message.
        public let gCMMessage: Message?
        /// The SMS message configuration.
        public let sMSMessage: CampaignSmsMessage?

        public init(aDMMessage: Message? = nil, aPNSMessage: Message? = nil, baiduMessage: Message? = nil, defaultMessage: Message? = nil, emailMessage: CampaignEmailMessage? = nil, gCMMessage: Message? = nil, sMSMessage: CampaignSmsMessage? = nil) {
            self.aDMMessage = aDMMessage
            self.aPNSMessage = aPNSMessage
            self.baiduMessage = baiduMessage
            self.defaultMessage = defaultMessage
            self.emailMessage = emailMessage
            self.gCMMessage = gCMMessage
            self.sMSMessage = sMSMessage
        }

        private enum CodingKeys: String, CodingKey {
            case aDMMessage = "ADMMessage"
            case aPNSMessage = "APNSMessage"
            case baiduMessage = "BaiduMessage"
            case defaultMessage = "DefaultMessage"
            case emailMessage = "EmailMessage"
            case gCMMessage = "GCMMessage"
            case sMSMessage = "SMSMessage"
        }
    }

    public struct MessageRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Addresses", required: false, type: .map), 
            AWSShapeMember(label: "Context", required: false, type: .map), 
            AWSShapeMember(label: "Endpoints", required: false, type: .map), 
            AWSShapeMember(label: "MessageConfiguration", required: false, type: .structure), 
            AWSShapeMember(label: "TraceId", required: false, type: .string)
        ]
        /// A map of key-value pairs, where each key is an address and each value is an AddressConfiguration object. An address can be a push notification token, a phone number, or an email address.
        public let addresses: [String: AddressConfiguration]?
        /// A map of custom attributes to attributes to be attached to the message. This payload is added to the push notification's 'data.pinpoint' object or added to the email/sms delivery receipt event attributes.
        public let context: [String: String]?
        /// A map of key-value pairs, where each key is an endpoint ID and each value is an EndpointSendConfiguration object. Within an EndpointSendConfiguration object, you can tailor the message for an endpoint by specifying message overrides or substitutions.
        public let endpoints: [String: EndpointSendConfiguration]?
        /// Message configuration.
        public let messageConfiguration: DirectMessageConfiguration?
        /// A unique ID that you can use to trace a message. This ID is visible to recipients.
        public let traceId: String?

        public init(addresses: [String: AddressConfiguration]? = nil, context: [String: String]? = nil, endpoints: [String: EndpointSendConfiguration]? = nil, messageConfiguration: DirectMessageConfiguration? = nil, traceId: String? = nil) {
            self.addresses = addresses
            self.context = context
            self.endpoints = endpoints
            self.messageConfiguration = messageConfiguration
            self.traceId = traceId
        }

        private enum CodingKeys: String, CodingKey {
            case addresses = "Addresses"
            case context = "Context"
            case endpoints = "Endpoints"
            case messageConfiguration = "MessageConfiguration"
            case traceId = "TraceId"
        }
    }

    public struct MessageResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", required: false, type: .string), 
            AWSShapeMember(label: "EndpointResult", required: false, type: .map), 
            AWSShapeMember(label: "RequestId", required: false, type: .string), 
            AWSShapeMember(label: "Result", required: false, type: .map)
        ]
        /// Application id of the message.
        public let applicationId: String?
        /// A map containing a multi part response for each address, with the endpointId as the key and the result as the value.
        public let endpointResult: [String: EndpointMessageResult]?
        /// Original request Id for which this message was delivered.
        public let requestId: String?
        /// A map containing a multi part response for each address, with the address as the key(Email address, phone number or push token) and the result as the value.
        public let result: [String: MessageResult]?

        public init(applicationId: String? = nil, endpointResult: [String: EndpointMessageResult]? = nil, requestId: String? = nil, result: [String: MessageResult]? = nil) {
            self.applicationId = applicationId
            self.endpointResult = endpointResult
            self.requestId = requestId
            self.result = result
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "ApplicationId"
            case endpointResult = "EndpointResult"
            case requestId = "RequestId"
            case result = "Result"
        }
    }

    public struct MessageResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DeliveryStatus", required: false, type: .enum), 
            AWSShapeMember(label: "MessageId", required: false, type: .string), 
            AWSShapeMember(label: "StatusCode", required: false, type: .integer), 
            AWSShapeMember(label: "StatusMessage", required: false, type: .string), 
            AWSShapeMember(label: "UpdatedToken", required: false, type: .string)
        ]
        /// The delivery status of the message. Possible values:
        /// SUCCESS - The message was successfully delivered to the endpoint.
        /// TRANSIENT_FAILURE - A temporary error occurred. Amazon Pinpoint will attempt to deliver the message again later.
        /// FAILURE_PERMANENT - An error occurred when delivering the message to the endpoint. Amazon Pinpoint won't attempt to send the message again.
        /// TIMEOUT - The message couldn't be sent within the timeout period.
        /// QUIET_TIME - The local time for the endpoint was within the QuietTime for the campaign or app.
        /// DAILY_CAP - The endpoint has received the maximum number of messages it can receive within a 24-hour period.
        /// HOLDOUT - The endpoint was in a hold out treatment for the campaign.
        /// THROTTLED - Amazon Pinpoint throttled sending to this endpoint.
        /// EXPIRED - The endpoint address is expired.
        /// CAMPAIGN_CAP - The endpoint received the maximum number of messages allowed by the campaign.
        /// SERVICE_FAILURE - A service-level failure prevented Amazon Pinpoint from delivering the message.
        /// UNKNOWN - An unknown error occurred.
        public let deliveryStatus: DeliveryStatus?
        /// Unique message identifier associated with the message that was sent.
        public let messageId: String?
        /// Downstream service status code.
        public let statusCode: Int32?
        /// Status message for message delivery.
        public let statusMessage: String?
        /// If token was updated as part of delivery. (This is GCM Specific)
        public let updatedToken: String?

        public init(deliveryStatus: DeliveryStatus? = nil, messageId: String? = nil, statusCode: Int32? = nil, statusMessage: String? = nil, updatedToken: String? = nil) {
            self.deliveryStatus = deliveryStatus
            self.messageId = messageId
            self.statusCode = statusCode
            self.statusMessage = statusMessage
            self.updatedToken = updatedToken
        }

        private enum CodingKeys: String, CodingKey {
            case deliveryStatus = "DeliveryStatus"
            case messageId = "MessageId"
            case statusCode = "StatusCode"
            case statusMessage = "StatusMessage"
            case updatedToken = "UpdatedToken"
        }
    }

    public enum MessageType: String, CustomStringConvertible, Codable {
        case transactional = "TRANSACTIONAL"
        case promotional = "PROMOTIONAL"
        public var description: String { return self.rawValue }
    }

    public struct MetricDimension: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ComparisonOperator", required: false, type: .string), 
            AWSShapeMember(label: "Value", required: false, type: .double)
        ]
        /// The operator that you're using to compare metric values. Possible values: GREATER_THAN, LESS_THAN, GREATER_THAN_OR_EQUAL, LESS_THAN_OR_EQUAL, or EQUAL
        public let comparisonOperator: String?
        /// The value to be compared.
        public let value: Double?

        public init(comparisonOperator: String? = nil, value: Double? = nil) {
            self.comparisonOperator = comparisonOperator
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case comparisonOperator = "ComparisonOperator"
            case value = "Value"
        }
    }

    public enum Mode: String, CustomStringConvertible, Codable {
        case delivery = "DELIVERY"
        case filter = "FILTER"
        public var description: String { return self.rawValue }
    }

    public struct NumberValidateRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "IsoCountryCode", required: false, type: .string), 
            AWSShapeMember(label: "PhoneNumber", required: false, type: .string)
        ]
        /// (Optional) The two-character ISO country code for the country or region where the phone number was originally registered.
        public let isoCountryCode: String?
        /// The phone number to get information about. The phone number that you provide should include a country code. If the number doesn't include a valid country code, the operation might result in an error.
        public let phoneNumber: String?

        public init(isoCountryCode: String? = nil, phoneNumber: String? = nil) {
            self.isoCountryCode = isoCountryCode
            self.phoneNumber = phoneNumber
        }

        private enum CodingKeys: String, CodingKey {
            case isoCountryCode = "IsoCountryCode"
            case phoneNumber = "PhoneNumber"
        }
    }

    public struct NumberValidateResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Carrier", required: false, type: .string), 
            AWSShapeMember(label: "City", required: false, type: .string), 
            AWSShapeMember(label: "CleansedPhoneNumberE164", required: false, type: .string), 
            AWSShapeMember(label: "CleansedPhoneNumberNational", required: false, type: .string), 
            AWSShapeMember(label: "Country", required: false, type: .string), 
            AWSShapeMember(label: "CountryCodeIso2", required: false, type: .string), 
            AWSShapeMember(label: "CountryCodeNumeric", required: false, type: .string), 
            AWSShapeMember(label: "County", required: false, type: .string), 
            AWSShapeMember(label: "OriginalCountryCodeIso2", required: false, type: .string), 
            AWSShapeMember(label: "OriginalPhoneNumber", required: false, type: .string), 
            AWSShapeMember(label: "PhoneType", required: false, type: .string), 
            AWSShapeMember(label: "PhoneTypeCode", required: false, type: .integer), 
            AWSShapeMember(label: "Timezone", required: false, type: .string), 
            AWSShapeMember(label: "ZipCode", required: false, type: .string)
        ]
        /// The carrier or servive provider that the phone number is currently registered with.
        public let carrier: String?
        /// The city where the phone number was originally registered.
        public let city: String?
        /// The cleansed phone number, shown in E.164 format.
        public let cleansedPhoneNumberE164: String?
        /// The cleansed phone number, shown in the local phone number format.
        public let cleansedPhoneNumberNational: String?
        /// The country or region where the phone number was originally registered.
        public let country: String?
        /// The two-character ISO code for the country or region where the phone number was originally registered.
        public let countryCodeIso2: String?
        /// The numeric code for the country or region where the phone number was originally registered.
        public let countryCodeNumeric: String?
        /// The county where the phone number was originally registered.
        public let county: String?
        /// The two-character code (in ISO 3166-1 alpha-2 format) for the country or region in the request body.
        public let originalCountryCodeIso2: String?
        /// The phone number that you included in the request body.
        public let originalPhoneNumber: String?
        /// A description of the phone type. Possible values are MOBILE, LANDLINE, VOIP, INVALID, PREPAID, and OTHER.
        public let phoneType: String?
        /// The phone type, represented by an integer. Possible values include 0 (MOBILE), 1 (LANDLINE), 2 (VOIP), 3 (INVALID), 4 (OTHER), and 5 (PREPAID).
        public let phoneTypeCode: Int32?
        /// The time zone for the location where the phone number was originally registered.
        public let timezone: String?
        /// The postal code for the location where the phone number was originally registered.
        public let zipCode: String?

        public init(carrier: String? = nil, city: String? = nil, cleansedPhoneNumberE164: String? = nil, cleansedPhoneNumberNational: String? = nil, country: String? = nil, countryCodeIso2: String? = nil, countryCodeNumeric: String? = nil, county: String? = nil, originalCountryCodeIso2: String? = nil, originalPhoneNumber: String? = nil, phoneType: String? = nil, phoneTypeCode: Int32? = nil, timezone: String? = nil, zipCode: String? = nil) {
            self.carrier = carrier
            self.city = city
            self.cleansedPhoneNumberE164 = cleansedPhoneNumberE164
            self.cleansedPhoneNumberNational = cleansedPhoneNumberNational
            self.country = country
            self.countryCodeIso2 = countryCodeIso2
            self.countryCodeNumeric = countryCodeNumeric
            self.county = county
            self.originalCountryCodeIso2 = originalCountryCodeIso2
            self.originalPhoneNumber = originalPhoneNumber
            self.phoneType = phoneType
            self.phoneTypeCode = phoneTypeCode
            self.timezone = timezone
            self.zipCode = zipCode
        }

        private enum CodingKeys: String, CodingKey {
            case carrier = "Carrier"
            case city = "City"
            case cleansedPhoneNumberE164 = "CleansedPhoneNumberE164"
            case cleansedPhoneNumberNational = "CleansedPhoneNumberNational"
            case country = "Country"
            case countryCodeIso2 = "CountryCodeIso2"
            case countryCodeNumeric = "CountryCodeNumeric"
            case county = "County"
            case originalCountryCodeIso2 = "OriginalCountryCodeIso2"
            case originalPhoneNumber = "OriginalPhoneNumber"
            case phoneType = "PhoneType"
            case phoneTypeCode = "PhoneTypeCode"
            case timezone = "Timezone"
            case zipCode = "ZipCode"
        }
    }

    public struct PhoneNumberValidateRequest: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "NumberValidateRequest"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NumberValidateRequest", required: true, type: .structure)
        ]
        public let numberValidateRequest: NumberValidateRequest

        public init(numberValidateRequest: NumberValidateRequest) {
            self.numberValidateRequest = numberValidateRequest
        }

        private enum CodingKeys: String, CodingKey {
            case numberValidateRequest = "NumberValidateRequest"
        }
    }

    public struct PhoneNumberValidateResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "NumberValidateResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NumberValidateResponse", required: true, type: .structure)
        ]
        public let numberValidateResponse: NumberValidateResponse

        public init(numberValidateResponse: NumberValidateResponse) {
            self.numberValidateResponse = numberValidateResponse
        }

        private enum CodingKeys: String, CodingKey {
            case numberValidateResponse = "NumberValidateResponse"
        }
    }

    public struct PublicEndpoint: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Address", required: false, type: .string), 
            AWSShapeMember(label: "Attributes", required: false, type: .map), 
            AWSShapeMember(label: "ChannelType", required: false, type: .enum), 
            AWSShapeMember(label: "Demographic", required: false, type: .structure), 
            AWSShapeMember(label: "EffectiveDate", required: false, type: .string), 
            AWSShapeMember(label: "EndpointStatus", required: false, type: .string), 
            AWSShapeMember(label: "Location", required: false, type: .structure), 
            AWSShapeMember(label: "Metrics", required: false, type: .map), 
            AWSShapeMember(label: "OptOut", required: false, type: .string), 
            AWSShapeMember(label: "RequestId", required: false, type: .string), 
            AWSShapeMember(label: "User", required: false, type: .structure)
        ]
        /// The unique identifier for the recipient. For example, an address could be a device token, email address, or mobile phone number.
        public let address: String?
        /// Custom attributes that your app reports to Amazon Pinpoint. You can use these attributes as selection criteria when you create a segment.
        public let attributes: [String: [String]]?
        /// The channel type.
        /// Valid values: APNS, GCM
        public let channelType: ChannelType?
        /// The endpoint demographic attributes.
        public let demographic: EndpointDemographic?
        /// The date and time when the endpoint was last updated, in  ISO 8601 format.
        public let effectiveDate: String?
        /// The status of the endpoint. If the update fails, the value is INACTIVE. If the endpoint is updated successfully, the value is ACTIVE.
        public let endpointStatus: String?
        /// The endpoint location attributes.
        public let location: EndpointLocation?
        /// Custom metrics that your app reports to Amazon Pinpoint.
        public let metrics: [String: Double]?
        /// Indicates whether a user has opted out of receiving messages with one of the following values:
        /// ALL - User has opted out of all messages.
        /// NONE - Users has not opted out and receives all messages.
        public let optOut: String?
        /// A unique identifier that is generated each time the endpoint is updated.
        public let requestId: String?
        /// Custom user-specific attributes that your app reports to Amazon Pinpoint.
        public let user: EndpointUser?

        public init(address: String? = nil, attributes: [String: [String]]? = nil, channelType: ChannelType? = nil, demographic: EndpointDemographic? = nil, effectiveDate: String? = nil, endpointStatus: String? = nil, location: EndpointLocation? = nil, metrics: [String: Double]? = nil, optOut: String? = nil, requestId: String? = nil, user: EndpointUser? = nil) {
            self.address = address
            self.attributes = attributes
            self.channelType = channelType
            self.demographic = demographic
            self.effectiveDate = effectiveDate
            self.endpointStatus = endpointStatus
            self.location = location
            self.metrics = metrics
            self.optOut = optOut
            self.requestId = requestId
            self.user = user
        }

        private enum CodingKeys: String, CodingKey {
            case address = "Address"
            case attributes = "Attributes"
            case channelType = "ChannelType"
            case demographic = "Demographic"
            case effectiveDate = "EffectiveDate"
            case endpointStatus = "EndpointStatus"
            case location = "Location"
            case metrics = "Metrics"
            case optOut = "OptOut"
            case requestId = "RequestId"
            case user = "User"
        }
    }

    public struct PutEventStreamRequest: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "WriteEventStream"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string), 
            AWSShapeMember(label: "WriteEventStream", required: true, type: .structure)
        ]
        public let applicationId: String
        public let writeEventStream: WriteEventStream

        public init(applicationId: String, writeEventStream: WriteEventStream) {
            self.applicationId = applicationId
            self.writeEventStream = writeEventStream
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
            case writeEventStream = "WriteEventStream"
        }
    }

    public struct PutEventStreamResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "EventStream"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "EventStream", required: true, type: .structure)
        ]
        public let eventStream: EventStream

        public init(eventStream: EventStream) {
            self.eventStream = eventStream
        }

        private enum CodingKeys: String, CodingKey {
            case eventStream = "EventStream"
        }
    }

    public struct PutEventsRequest: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "EventsRequest"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string), 
            AWSShapeMember(label: "EventsRequest", required: true, type: .structure)
        ]
        public let applicationId: String
        public let eventsRequest: EventsRequest

        public init(applicationId: String, eventsRequest: EventsRequest) {
            self.applicationId = applicationId
            self.eventsRequest = eventsRequest
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
            case eventsRequest = "EventsRequest"
        }
    }

    public struct PutEventsResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "EventsResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "EventsResponse", required: true, type: .structure)
        ]
        public let eventsResponse: EventsResponse

        public init(eventsResponse: EventsResponse) {
            self.eventsResponse = eventsResponse
        }

        private enum CodingKeys: String, CodingKey {
            case eventsResponse = "EventsResponse"
        }
    }

    public struct QuietTime: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "End", required: false, type: .string), 
            AWSShapeMember(label: "Start", required: false, type: .string)
        ]
        /// The time at which quiet time should end. The value that you specify has to be in HH:mm format, where HH is the hour in 24-hour format (with a leading zero, if applicable), and mm is the minutes. For example, use 02:30 to represent 2:30 AM, or 14:30 to represent 2:30 PM.
        public let end: String?
        /// The time at which quiet time should begin. The value that you specify has to be in HH:mm format, where HH is the hour in 24-hour format (with a leading zero, if applicable), and mm is the minutes. For example, use 02:30 to represent 2:30 AM, or 14:30 to represent 2:30 PM.
        public let start: String?

        public init(end: String? = nil, start: String? = nil) {
            self.end = end
            self.start = start
        }

        private enum CodingKeys: String, CodingKey {
            case end = "End"
            case start = "Start"
        }
    }

    public struct RawEmail: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Data", required: false, type: .blob)
        ]
        /// The raw email message itself. Then entire message must be base64-encoded.
        public let data: Data?

        public init(data: Data? = nil) {
            self.data = data
        }

        private enum CodingKeys: String, CodingKey {
            case data = "Data"
        }
    }

    public struct RecencyDimension: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Duration", required: false, type: .enum), 
            AWSShapeMember(label: "RecencyType", required: false, type: .enum)
        ]
        /// The length of time during which users have been active or inactive with your app.
        /// Valid values: HR_24, DAY_7, DAY_14, DAY_30
        public let duration: Duration?
        /// The recency dimension type:
        /// ACTIVE - Users who have used your app within the specified duration are included in the segment.
        /// INACTIVE - Users who have not used your app within the specified duration are included in the segment.
        public let recencyType: RecencyType?

        public init(duration: Duration? = nil, recencyType: RecencyType? = nil) {
            self.duration = duration
            self.recencyType = recencyType
        }

        private enum CodingKeys: String, CodingKey {
            case duration = "Duration"
            case recencyType = "RecencyType"
        }
    }

    public enum RecencyType: String, CustomStringConvertible, Codable {
        case active = "ACTIVE"
        case inactive = "INACTIVE"
        public var description: String { return self.rawValue }
    }

    public struct RemoveAttributesRequest: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "UpdateAttributesRequest"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string), 
            AWSShapeMember(label: "AttributeType", location: .uri(locationName: "attribute-type"), required: true, type: .string), 
            AWSShapeMember(label: "UpdateAttributesRequest", required: true, type: .structure)
        ]
        public let applicationId: String
        public let attributeType: String
        public let updateAttributesRequest: UpdateAttributesRequest

        public init(applicationId: String, attributeType: String, updateAttributesRequest: UpdateAttributesRequest) {
            self.applicationId = applicationId
            self.attributeType = attributeType
            self.updateAttributesRequest = updateAttributesRequest
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
            case attributeType = "attribute-type"
            case updateAttributesRequest = "UpdateAttributesRequest"
        }
    }

    public struct RemoveAttributesResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "AttributesResource"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AttributesResource", required: true, type: .structure)
        ]
        public let attributesResource: AttributesResource

        public init(attributesResource: AttributesResource) {
            self.attributesResource = attributesResource
        }

        private enum CodingKeys: String, CodingKey {
            case attributesResource = "AttributesResource"
        }
    }

    public struct SMSChannelRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Enabled", required: false, type: .boolean), 
            AWSShapeMember(label: "SenderId", required: false, type: .string), 
            AWSShapeMember(label: "ShortCode", required: false, type: .string)
        ]
        /// If the channel is enabled for sending messages.
        public let enabled: Bool?
        /// Sender identifier of your messages.
        public let senderId: String?
        /// ShortCode registered with phone provider.
        public let shortCode: String?

        public init(enabled: Bool? = nil, senderId: String? = nil, shortCode: String? = nil) {
            self.enabled = enabled
            self.senderId = senderId
            self.shortCode = shortCode
        }

        private enum CodingKeys: String, CodingKey {
            case enabled = "Enabled"
            case senderId = "SenderId"
            case shortCode = "ShortCode"
        }
    }

    public struct SMSChannelResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", required: false, type: .string), 
            AWSShapeMember(label: "CreationDate", required: false, type: .string), 
            AWSShapeMember(label: "Enabled", required: false, type: .boolean), 
            AWSShapeMember(label: "HasCredential", required: false, type: .boolean), 
            AWSShapeMember(label: "Id", required: false, type: .string), 
            AWSShapeMember(label: "IsArchived", required: false, type: .boolean), 
            AWSShapeMember(label: "LastModifiedBy", required: false, type: .string), 
            AWSShapeMember(label: "LastModifiedDate", required: false, type: .string), 
            AWSShapeMember(label: "Platform", required: false, type: .string), 
            AWSShapeMember(label: "PromotionalMessagesPerSecond", required: false, type: .integer), 
            AWSShapeMember(label: "SenderId", required: false, type: .string), 
            AWSShapeMember(label: "ShortCode", required: false, type: .string), 
            AWSShapeMember(label: "TransactionalMessagesPerSecond", required: false, type: .integer), 
            AWSShapeMember(label: "Version", required: false, type: .integer)
        ]
        /// The unique ID of the application to which the SMS channel belongs.
        public let applicationId: String?
        /// The date that the settings were last updated in ISO 8601 format.
        public let creationDate: String?
        /// If the channel is enabled for sending messages.
        public let enabled: Bool?
        /// Not used. Retained for backwards compatibility.
        public let hasCredential: Bool?
        /// Channel ID. Not used, only for backwards compatibility.
        public let id: String?
        /// Is this channel archived
        public let isArchived: Bool?
        /// Who last updated this entry
        public let lastModifiedBy: String?
        /// Last date this was updated
        public let lastModifiedDate: String?
        /// Platform type. Will be "SMS"
        public let platform: String?
        /// Promotional messages per second that can be sent
        public let promotionalMessagesPerSecond: Int32?
        /// Sender identifier of your messages.
        public let senderId: String?
        /// The short code registered with the phone provider.
        public let shortCode: String?
        /// Transactional messages per second that can be sent
        public let transactionalMessagesPerSecond: Int32?
        /// Version of channel
        public let version: Int32?

        public init(applicationId: String? = nil, creationDate: String? = nil, enabled: Bool? = nil, hasCredential: Bool? = nil, id: String? = nil, isArchived: Bool? = nil, lastModifiedBy: String? = nil, lastModifiedDate: String? = nil, platform: String? = nil, promotionalMessagesPerSecond: Int32? = nil, senderId: String? = nil, shortCode: String? = nil, transactionalMessagesPerSecond: Int32? = nil, version: Int32? = nil) {
            self.applicationId = applicationId
            self.creationDate = creationDate
            self.enabled = enabled
            self.hasCredential = hasCredential
            self.id = id
            self.isArchived = isArchived
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedDate = lastModifiedDate
            self.platform = platform
            self.promotionalMessagesPerSecond = promotionalMessagesPerSecond
            self.senderId = senderId
            self.shortCode = shortCode
            self.transactionalMessagesPerSecond = transactionalMessagesPerSecond
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "ApplicationId"
            case creationDate = "CreationDate"
            case enabled = "Enabled"
            case hasCredential = "HasCredential"
            case id = "Id"
            case isArchived = "IsArchived"
            case lastModifiedBy = "LastModifiedBy"
            case lastModifiedDate = "LastModifiedDate"
            case platform = "Platform"
            case promotionalMessagesPerSecond = "PromotionalMessagesPerSecond"
            case senderId = "SenderId"
            case shortCode = "ShortCode"
            case transactionalMessagesPerSecond = "TransactionalMessagesPerSecond"
            case version = "Version"
        }
    }

    public struct SMSMessage: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Body", required: false, type: .string), 
            AWSShapeMember(label: "Keyword", required: false, type: .string), 
            AWSShapeMember(label: "MessageType", required: false, type: .enum), 
            AWSShapeMember(label: "OriginationNumber", required: false, type: .string), 
            AWSShapeMember(label: "SenderId", required: false, type: .string), 
            AWSShapeMember(label: "Substitutions", required: false, type: .map)
        ]
        /// The body of the SMS message.
        public let body: String?
        /// The SMS program name that you provided to AWS Support when you requested your dedicated number.
        public let keyword: String?
        /// Is this a transaction priority message or lower priority.
        public let messageType: MessageType?
        /// The phone number that the SMS message originates from. Specify one of the dedicated long codes or short codes that you requested from AWS Support and that is assigned to your account. If this attribute is not specified, Amazon Pinpoint randomly assigns a long code.
        public let originationNumber: String?
        /// The sender ID that is shown as the message sender on the recipient's device. Support for sender IDs varies by country or region.
        public let senderId: String?
        /// Default message substitutions. Can be overridden by individual address substitutions.
        public let substitutions: [String: [String]]?

        public init(body: String? = nil, keyword: String? = nil, messageType: MessageType? = nil, originationNumber: String? = nil, senderId: String? = nil, substitutions: [String: [String]]? = nil) {
            self.body = body
            self.keyword = keyword
            self.messageType = messageType
            self.originationNumber = originationNumber
            self.senderId = senderId
            self.substitutions = substitutions
        }

        private enum CodingKeys: String, CodingKey {
            case body = "Body"
            case keyword = "Keyword"
            case messageType = "MessageType"
            case originationNumber = "OriginationNumber"
            case senderId = "SenderId"
            case substitutions = "Substitutions"
        }
    }

    public struct Schedule: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "EndTime", required: false, type: .string), 
            AWSShapeMember(label: "EventFilter", required: false, type: .structure), 
            AWSShapeMember(label: "Frequency", required: false, type: .enum), 
            AWSShapeMember(label: "IsLocalTime", required: false, type: .boolean), 
            AWSShapeMember(label: "QuietTime", required: false, type: .structure), 
            AWSShapeMember(label: "StartTime", required: false, type: .string), 
            AWSShapeMember(label: "Timezone", required: false, type: .string)
        ]
        /// The scheduled time that the campaign ends in ISO 8601 format.
        public let endTime: String?
        /// Defines the type of events that can trigger the campaign. Used when the Frequency is set to EVENT.
        public let eventFilter: CampaignEventFilter?
        /// How often the campaign delivers messages.
        /// Valid values:
        /// ONCE
        /// HOURLY
        /// DAILY
        /// WEEKLY
        /// MONTHLY
        /// EVENT
        public let frequency: Frequency?
        /// Indicates whether the campaign schedule takes effect according to each user's local time.
        public let isLocalTime: Bool?
        /// The default quiet time for the campaign. The campaign doesn't send messages to endpoints during the quiet time.
        /// Note: Make sure that your endpoints include the Demographics.Timezone attribute if you plan to enable a quiet time for your campaign. If your endpoints don't include this attribute, they'll receive the messages that you send them, even if quiet time is enabled.
        /// When you set up a campaign to use quiet time, the campaign doesn't send messages during the time range you specified, as long as all of the following are true:
        /// - The endpoint includes a valid Demographic.Timezone attribute.
        /// - The current time in the endpoint's time zone is later than or equal to the time specified in the QuietTime.Start attribute for the campaign.
        /// - The current time in the endpoint's time zone is earlier than or equal to the time specified in the QuietTime.End attribute for the campaign.
        public let quietTime: QuietTime?
        /// The scheduled time that the campaign begins in ISO 8601 format.
        public let startTime: String?
        /// The starting UTC offset for the schedule if the value for isLocalTime is true
        /// Valid values: 
        /// UTC
        /// UTC+01
        /// UTC+02
        /// UTC+03
        /// UTC+03:30
        /// UTC+04
        /// UTC+04:30
        /// UTC+05
        /// UTC+05:30
        /// UTC+05:45
        /// UTC+06
        /// UTC+06:30
        /// UTC+07
        /// UTC+08
        /// UTC+09
        /// UTC+09:30
        /// UTC+10
        /// UTC+10:30
        /// UTC+11
        /// UTC+12
        /// UTC+13
        /// UTC-02
        /// UTC-03
        /// UTC-04
        /// UTC-05
        /// UTC-06
        /// UTC-07
        /// UTC-08
        /// UTC-09
        /// UTC-10
        /// UTC-11
        public let timezone: String?

        public init(endTime: String? = nil, eventFilter: CampaignEventFilter? = nil, frequency: Frequency? = nil, isLocalTime: Bool? = nil, quietTime: QuietTime? = nil, startTime: String? = nil, timezone: String? = nil) {
            self.endTime = endTime
            self.eventFilter = eventFilter
            self.frequency = frequency
            self.isLocalTime = isLocalTime
            self.quietTime = quietTime
            self.startTime = startTime
            self.timezone = timezone
        }

        private enum CodingKeys: String, CodingKey {
            case endTime = "EndTime"
            case eventFilter = "EventFilter"
            case frequency = "Frequency"
            case isLocalTime = "IsLocalTime"
            case quietTime = "QuietTime"
            case startTime = "StartTime"
            case timezone = "Timezone"
        }
    }

    public struct SegmentBehaviors: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Recency", required: false, type: .structure)
        ]
        /// The recency of use.
        public let recency: RecencyDimension?

        public init(recency: RecencyDimension? = nil) {
            self.recency = recency
        }

        private enum CodingKeys: String, CodingKey {
            case recency = "Recency"
        }
    }

    public struct SegmentDemographics: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AppVersion", required: false, type: .structure), 
            AWSShapeMember(label: "Channel", required: false, type: .structure), 
            AWSShapeMember(label: "DeviceType", required: false, type: .structure), 
            AWSShapeMember(label: "Make", required: false, type: .structure), 
            AWSShapeMember(label: "Model", required: false, type: .structure), 
            AWSShapeMember(label: "Platform", required: false, type: .structure)
        ]
        /// The app version criteria for the segment.
        public let appVersion: SetDimension?
        /// The channel criteria for the segment.
        public let channel: SetDimension?
        /// The device type criteria for the segment.
        public let deviceType: SetDimension?
        /// The device make criteria for the segment.
        public let make: SetDimension?
        /// The device model criteria for the segment.
        public let model: SetDimension?
        /// The device platform criteria for the segment.
        public let platform: SetDimension?

        public init(appVersion: SetDimension? = nil, channel: SetDimension? = nil, deviceType: SetDimension? = nil, make: SetDimension? = nil, model: SetDimension? = nil, platform: SetDimension? = nil) {
            self.appVersion = appVersion
            self.channel = channel
            self.deviceType = deviceType
            self.make = make
            self.model = model
            self.platform = platform
        }

        private enum CodingKeys: String, CodingKey {
            case appVersion = "AppVersion"
            case channel = "Channel"
            case deviceType = "DeviceType"
            case make = "Make"
            case model = "Model"
            case platform = "Platform"
        }
    }

    public struct SegmentDimensions: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Attributes", required: false, type: .map), 
            AWSShapeMember(label: "Behavior", required: false, type: .structure), 
            AWSShapeMember(label: "Demographic", required: false, type: .structure), 
            AWSShapeMember(label: "Location", required: false, type: .structure), 
            AWSShapeMember(label: "Metrics", required: false, type: .map), 
            AWSShapeMember(label: "UserAttributes", required: false, type: .map)
        ]
        /// Custom segment attributes.
        public let attributes: [String: AttributeDimension]?
        /// The segment behaviors attributes.
        public let behavior: SegmentBehaviors?
        /// The segment demographics attributes.
        public let demographic: SegmentDemographics?
        /// The segment location attributes.
        public let location: SegmentLocation?
        /// Custom segment metrics.
        public let metrics: [String: MetricDimension]?
        /// Custom segment user attributes.
        public let userAttributes: [String: AttributeDimension]?

        public init(attributes: [String: AttributeDimension]? = nil, behavior: SegmentBehaviors? = nil, demographic: SegmentDemographics? = nil, location: SegmentLocation? = nil, metrics: [String: MetricDimension]? = nil, userAttributes: [String: AttributeDimension]? = nil) {
            self.attributes = attributes
            self.behavior = behavior
            self.demographic = demographic
            self.location = location
            self.metrics = metrics
            self.userAttributes = userAttributes
        }

        private enum CodingKeys: String, CodingKey {
            case attributes = "Attributes"
            case behavior = "Behavior"
            case demographic = "Demographic"
            case location = "Location"
            case metrics = "Metrics"
            case userAttributes = "UserAttributes"
        }
    }

    public struct SegmentGroup: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Dimensions", required: false, type: .list), 
            AWSShapeMember(label: "SourceSegments", required: false, type: .list), 
            AWSShapeMember(label: "SourceType", required: false, type: .enum), 
            AWSShapeMember(label: "Type", required: false, type: .enum)
        ]
        /// List of dimensions to include or exclude.
        public let dimensions: [SegmentDimensions]?
        /// The base segment that you build your segment on. The source segment defines the starting "universe" of endpoints. When you add dimensions to the segment, it filters the source segment based on the dimensions that you specify. You can specify more than one dimensional segment. You can only specify one imported segment.
        /// NOTE: If you specify an imported segment for this attribute, the segment size estimate that appears in the Amazon Pinpoint console shows the size of the imported segment, without any filters applied to it.
        public let sourceSegments: [SegmentReference]?
        /// Specify how to handle multiple source segments. For example, if you specify three source segments, should the resulting segment be based on any or all of the segments? Acceptable values: ANY or ALL.
        public let sourceType: SourceType?
        /// Specify how to handle multiple segment dimensions. For example, if you specify three dimensions, should the resulting segment include endpoints that are matched by all, any, or none of the dimensions? Acceptable values: ALL, ANY, or NONE.
        public let `type`: `Type`?

        public init(dimensions: [SegmentDimensions]? = nil, sourceSegments: [SegmentReference]? = nil, sourceType: SourceType? = nil, type: `Type`? = nil) {
            self.dimensions = dimensions
            self.sourceSegments = sourceSegments
            self.sourceType = sourceType
            self.`type` = `type`
        }

        private enum CodingKeys: String, CodingKey {
            case dimensions = "Dimensions"
            case sourceSegments = "SourceSegments"
            case sourceType = "SourceType"
            case `type` = "Type"
        }
    }

    public struct SegmentGroupList: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Groups", required: false, type: .list), 
            AWSShapeMember(label: "Include", required: false, type: .enum)
        ]
        /// A set of segment criteria to evaluate.
        public let groups: [SegmentGroup]?
        /// Specify how to handle multiple segment groups. For example, if the segment includes three segment groups, should the resulting segment include endpoints that are matched by all, any, or none of the segment groups you created. Acceptable values: ALL, ANY, or NONE.
        public let include: Include?

        public init(groups: [SegmentGroup]? = nil, include: Include? = nil) {
            self.groups = groups
            self.include = include
        }

        private enum CodingKeys: String, CodingKey {
            case groups = "Groups"
            case include = "Include"
        }
    }

    public struct SegmentImportResource: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ChannelCounts", required: false, type: .map), 
            AWSShapeMember(label: "ExternalId", required: false, type: .string), 
            AWSShapeMember(label: "Format", required: false, type: .enum), 
            AWSShapeMember(label: "RoleArn", required: false, type: .string), 
            AWSShapeMember(label: "S3Url", required: false, type: .string), 
            AWSShapeMember(label: "Size", required: false, type: .integer)
        ]
        /// The number of channel types in the imported segment.
        public let channelCounts: [String: Int32]?
        /// (Deprecated) Your AWS account ID, which you assigned to the ExternalID key in an IAM trust policy. Used by Amazon Pinpoint to assume an IAM role. This requirement is removed, and external IDs are not recommended for IAM roles assumed by Amazon Pinpoint.
        public let externalId: String?
        /// The format of the endpoint files that were imported to create this segment.
        /// Valid values: CSV, JSON
        public let format: Format?
        /// The Amazon Resource Name (ARN) of an IAM role that grants Amazon Pinpoint access to the endpoints in Amazon S3.
        public let roleArn: String?
        /// The URL of the S3 bucket that the segment was imported from.
        public let s3Url: String?
        /// The number of endpoints that were successfully imported to create this segment.
        public let size: Int32?

        public init(channelCounts: [String: Int32]? = nil, externalId: String? = nil, format: Format? = nil, roleArn: String? = nil, s3Url: String? = nil, size: Int32? = nil) {
            self.channelCounts = channelCounts
            self.externalId = externalId
            self.format = format
            self.roleArn = roleArn
            self.s3Url = s3Url
            self.size = size
        }

        private enum CodingKeys: String, CodingKey {
            case channelCounts = "ChannelCounts"
            case externalId = "ExternalId"
            case format = "Format"
            case roleArn = "RoleArn"
            case s3Url = "S3Url"
            case size = "Size"
        }
    }

    public struct SegmentLocation: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Country", required: false, type: .structure), 
            AWSShapeMember(label: "GPSPoint", required: false, type: .structure)
        ]
        /// The country or region, in ISO 3166-1 alpha-2 format.
        public let country: SetDimension?
        /// The GPS Point dimension.
        public let gPSPoint: GPSPointDimension?

        public init(country: SetDimension? = nil, gPSPoint: GPSPointDimension? = nil) {
            self.country = country
            self.gPSPoint = gPSPoint
        }

        private enum CodingKeys: String, CodingKey {
            case country = "Country"
            case gPSPoint = "GPSPoint"
        }
    }

    public struct SegmentReference: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Id", required: false, type: .string), 
            AWSShapeMember(label: "Version", required: false, type: .integer)
        ]
        /// A unique identifier for the segment.
        public let id: String?
        /// If specified contains a specific version of the segment included.
        public let version: Int32?

        public init(id: String? = nil, version: Int32? = nil) {
            self.id = id
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case id = "Id"
            case version = "Version"
        }
    }

    public struct SegmentResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", required: false, type: .string), 
            AWSShapeMember(label: "Arn", required: false, type: .string), 
            AWSShapeMember(label: "CreationDate", required: false, type: .string), 
            AWSShapeMember(label: "Dimensions", required: false, type: .structure), 
            AWSShapeMember(label: "Id", required: false, type: .string), 
            AWSShapeMember(label: "ImportDefinition", required: false, type: .structure), 
            AWSShapeMember(label: "LastModifiedDate", required: false, type: .string), 
            AWSShapeMember(label: "Name", required: false, type: .string), 
            AWSShapeMember(label: "SegmentGroups", required: false, type: .structure), 
            AWSShapeMember(label: "SegmentType", required: false, type: .enum), 
            AWSShapeMember(label: "Version", required: false, type: .integer), 
            AWSShapeMember(label: "tags", location: .body(locationName: "tags"), required: false, type: .map)
        ]
        /// The ID of the application that the segment applies to.
        public let applicationId: String?
        /// The arn for the segment.
        public let arn: String?
        /// The date and time when the segment was created.
        public let creationDate: String?
        /// The segment dimensions attributes.
        public let dimensions: SegmentDimensions?
        /// The unique segment ID.
        public let id: String?
        /// The import job settings.
        public let importDefinition: SegmentImportResource?
        /// The date and time when the segment was last modified.
        public let lastModifiedDate: String?
        /// The name of the segment.
        public let name: String?
        /// A segment group, which consists of zero or more source segments, plus dimensions that are applied to those source segments.
        public let segmentGroups: SegmentGroupList?
        /// The segment type:
        /// DIMENSIONAL - A dynamic segment built from selection criteria based on endpoint data reported by your app. You create this type of segment by using the segment builder in the Amazon Pinpoint console or by making a POST request to the segments resource.
        /// IMPORT - A static segment built from an imported set of endpoint definitions. You create this type of segment by importing a segment in the Amazon Pinpoint console or by making a POST request to the jobs/import resource.
        public let segmentType: SegmentType?
        /// The segment version number.
        public let version: Int32?
        /// The Tags for the segment.
        public let tags: [String: String]?

        public init(applicationId: String? = nil, arn: String? = nil, creationDate: String? = nil, dimensions: SegmentDimensions? = nil, id: String? = nil, importDefinition: SegmentImportResource? = nil, lastModifiedDate: String? = nil, name: String? = nil, segmentGroups: SegmentGroupList? = nil, segmentType: SegmentType? = nil, tags: [String: String]? = nil, version: Int32? = nil) {
            self.applicationId = applicationId
            self.arn = arn
            self.creationDate = creationDate
            self.dimensions = dimensions
            self.id = id
            self.importDefinition = importDefinition
            self.lastModifiedDate = lastModifiedDate
            self.name = name
            self.segmentGroups = segmentGroups
            self.segmentType = segmentType
            self.version = version
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "ApplicationId"
            case arn = "Arn"
            case creationDate = "CreationDate"
            case dimensions = "Dimensions"
            case id = "Id"
            case importDefinition = "ImportDefinition"
            case lastModifiedDate = "LastModifiedDate"
            case name = "Name"
            case segmentGroups = "SegmentGroups"
            case segmentType = "SegmentType"
            case version = "Version"
            case tags = "tags"
        }
    }

    public enum SegmentType: String, CustomStringConvertible, Codable {
        case dimensional = "DIMENSIONAL"
        case `import` = "IMPORT"
        public var description: String { return self.rawValue }
    }

    public struct SegmentsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Item", required: false, type: .list), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]
        /// The list of segments.
        public let item: [SegmentResponse]?
        /// An identifier used to retrieve the next page of results. The token is null if no additional pages exist.
        public let nextToken: String?

        public init(item: [SegmentResponse]? = nil, nextToken: String? = nil) {
            self.item = item
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case item = "Item"
            case nextToken = "NextToken"
        }
    }

    public struct SendMessagesRequest: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "MessageRequest"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string), 
            AWSShapeMember(label: "MessageRequest", required: true, type: .structure)
        ]
        public let applicationId: String
        public let messageRequest: MessageRequest

        public init(applicationId: String, messageRequest: MessageRequest) {
            self.applicationId = applicationId
            self.messageRequest = messageRequest
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
            case messageRequest = "MessageRequest"
        }
    }

    public struct SendMessagesResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "MessageResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "MessageResponse", required: true, type: .structure)
        ]
        public let messageResponse: MessageResponse

        public init(messageResponse: MessageResponse) {
            self.messageResponse = messageResponse
        }

        private enum CodingKeys: String, CodingKey {
            case messageResponse = "MessageResponse"
        }
    }

    public struct SendUsersMessageRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Context", required: false, type: .map), 
            AWSShapeMember(label: "MessageConfiguration", required: false, type: .structure), 
            AWSShapeMember(label: "TraceId", required: false, type: .string), 
            AWSShapeMember(label: "Users", required: false, type: .map)
        ]
        /// A map of custom attribute-value pairs. Amazon Pinpoint adds these attributes to the data.pinpoint object in the body of the push notification payload. Amazon Pinpoint also provides these attributes in the events that it generates for users-messages deliveries.
        public let context: [String: String]?
        /// Message definitions for the default message and any messages that are tailored for specific channels.
        public let messageConfiguration: DirectMessageConfiguration?
        /// A unique ID that you can use to trace a message. This ID is visible to recipients.
        public let traceId: String?
        /// A map that associates user IDs with EndpointSendConfiguration objects. Within an EndpointSendConfiguration object, you can tailor the message for a user by specifying message overrides or substitutions.
        public let users: [String: EndpointSendConfiguration]?

        public init(context: [String: String]? = nil, messageConfiguration: DirectMessageConfiguration? = nil, traceId: String? = nil, users: [String: EndpointSendConfiguration]? = nil) {
            self.context = context
            self.messageConfiguration = messageConfiguration
            self.traceId = traceId
            self.users = users
        }

        private enum CodingKeys: String, CodingKey {
            case context = "Context"
            case messageConfiguration = "MessageConfiguration"
            case traceId = "TraceId"
            case users = "Users"
        }
    }

    public struct SendUsersMessageResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", required: false, type: .string), 
            AWSShapeMember(label: "RequestId", required: false, type: .string), 
            AWSShapeMember(label: "Result", required: false, type: .map)
        ]
        /// The unique ID of the Amazon Pinpoint project used to send the message.
        public let applicationId: String?
        /// The unique ID assigned to the users-messages request.
        public let requestId: String?
        /// An object that shows the endpoints that were messaged for each user. The object provides a list of user IDs. For each user ID, it provides the endpoint IDs that were messaged. For each endpoint ID, it provides an EndpointMessageResult object.
        public let result: [String: [String: EndpointMessageResult]]?

        public init(applicationId: String? = nil, requestId: String? = nil, result: [String: [String: EndpointMessageResult]]? = nil) {
            self.applicationId = applicationId
            self.requestId = requestId
            self.result = result
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "ApplicationId"
            case requestId = "RequestId"
            case result = "Result"
        }
    }

    public struct SendUsersMessagesRequest: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "SendUsersMessageRequest"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string), 
            AWSShapeMember(label: "SendUsersMessageRequest", required: true, type: .structure)
        ]
        public let applicationId: String
        public let sendUsersMessageRequest: SendUsersMessageRequest

        public init(applicationId: String, sendUsersMessageRequest: SendUsersMessageRequest) {
            self.applicationId = applicationId
            self.sendUsersMessageRequest = sendUsersMessageRequest
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
            case sendUsersMessageRequest = "SendUsersMessageRequest"
        }
    }

    public struct SendUsersMessagesResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "SendUsersMessageResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SendUsersMessageResponse", required: true, type: .structure)
        ]
        public let sendUsersMessageResponse: SendUsersMessageResponse

        public init(sendUsersMessageResponse: SendUsersMessageResponse) {
            self.sendUsersMessageResponse = sendUsersMessageResponse
        }

        private enum CodingKeys: String, CodingKey {
            case sendUsersMessageResponse = "SendUsersMessageResponse"
        }
    }

    public struct Session: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Duration", required: false, type: .integer), 
            AWSShapeMember(label: "Id", required: false, type: .string), 
            AWSShapeMember(label: "StartTimestamp", required: false, type: .string), 
            AWSShapeMember(label: "StopTimestamp", required: false, type: .string)
        ]
        /// The duration of the session, in milliseconds.
        public let duration: Int32?
        /// A unique identifier for the session.
        public let id: String?
        /// The date and time when the session began.
        public let startTimestamp: String?
        /// The date and time when the session ended.
        public let stopTimestamp: String?

        public init(duration: Int32? = nil, id: String? = nil, startTimestamp: String? = nil, stopTimestamp: String? = nil) {
            self.duration = duration
            self.id = id
            self.startTimestamp = startTimestamp
            self.stopTimestamp = stopTimestamp
        }

        private enum CodingKeys: String, CodingKey {
            case duration = "Duration"
            case id = "Id"
            case startTimestamp = "StartTimestamp"
            case stopTimestamp = "StopTimestamp"
        }
    }

    public struct SetDimension: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DimensionType", required: false, type: .enum), 
            AWSShapeMember(label: "Values", required: false, type: .list)
        ]
        /// The type of dimension:
        /// INCLUSIVE - Endpoints that match the criteria are included in the segment.
        /// EXCLUSIVE - Endpoints that match the criteria are excluded from the segment.
        public let dimensionType: DimensionType?
        /// The criteria values for the segment dimension. Endpoints with matching attribute values are included or excluded from the segment, depending on the setting for Type.
        public let values: [String]?

        public init(dimensionType: DimensionType? = nil, values: [String]? = nil) {
            self.dimensionType = dimensionType
            self.values = values
        }

        private enum CodingKeys: String, CodingKey {
            case dimensionType = "DimensionType"
            case values = "Values"
        }
    }

    public struct SimpleEmail: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "HtmlPart", required: false, type: .structure), 
            AWSShapeMember(label: "Subject", required: false, type: .structure), 
            AWSShapeMember(label: "TextPart", required: false, type: .structure)
        ]
        /// The content of the message, in HTML format. Use this for email clients that can process HTML. You can include clickable links, formatted text, and much more in an HTML message.
        public let htmlPart: SimpleEmailPart?
        /// The subject of the message: A short summary of the content, which will appear in the recipient's inbox.
        public let subject: SimpleEmailPart?
        /// The content of the message, in text format. Use this for text-based email clients, or clients on high-latency networks (such as mobile devices).
        public let textPart: SimpleEmailPart?

        public init(htmlPart: SimpleEmailPart? = nil, subject: SimpleEmailPart? = nil, textPart: SimpleEmailPart? = nil) {
            self.htmlPart = htmlPart
            self.subject = subject
            self.textPart = textPart
        }

        private enum CodingKeys: String, CodingKey {
            case htmlPart = "HtmlPart"
            case subject = "Subject"
            case textPart = "TextPart"
        }
    }

    public struct SimpleEmailPart: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Charset", required: false, type: .string), 
            AWSShapeMember(label: "Data", required: false, type: .string)
        ]
        /// The character set of the content.
        public let charset: String?
        /// The textual data of the content.
        public let data: String?

        public init(charset: String? = nil, data: String? = nil) {
            self.charset = charset
            self.data = data
        }

        private enum CodingKeys: String, CodingKey {
            case charset = "Charset"
            case data = "Data"
        }
    }

    public enum SourceType: String, CustomStringConvertible, Codable {
        case all = "ALL"
        case any = "ANY"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public struct TagResourceRequest: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "TagsModel"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ResourceArn", location: .uri(locationName: "resource-arn"), required: true, type: .string), 
            AWSShapeMember(label: "TagsModel", required: true, type: .structure)
        ]
        public let resourceArn: String
        public let tagsModel: TagsModel

        public init(resourceArn: String, tagsModel: TagsModel) {
            self.resourceArn = resourceArn
            self.tagsModel = tagsModel
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "resource-arn"
            case tagsModel = "TagsModel"
        }
    }

    public struct TagsModel: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "tags", location: .body(locationName: "tags"), required: true, type: .map)
        ]
        public let tags: [String: String]

        public init(tags: [String: String]) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct TreatmentResource: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Id", required: false, type: .string), 
            AWSShapeMember(label: "MessageConfiguration", required: false, type: .structure), 
            AWSShapeMember(label: "Schedule", required: false, type: .structure), 
            AWSShapeMember(label: "SizePercent", required: false, type: .integer), 
            AWSShapeMember(label: "State", required: false, type: .structure), 
            AWSShapeMember(label: "TreatmentDescription", required: false, type: .string), 
            AWSShapeMember(label: "TreatmentName", required: false, type: .string)
        ]
        /// The unique treatment ID.
        public let id: String?
        /// The message configuration settings.
        public let messageConfiguration: MessageConfiguration?
        /// The campaign schedule.
        public let schedule: Schedule?
        /// The allocated percentage of users for this treatment.
        public let sizePercent: Int32?
        /// The treatment status.
        public let state: CampaignState?
        /// A custom description for the treatment.
        public let treatmentDescription: String?
        /// The custom name of a variation of the campaign used for A/B testing.
        public let treatmentName: String?

        public init(id: String? = nil, messageConfiguration: MessageConfiguration? = nil, schedule: Schedule? = nil, sizePercent: Int32? = nil, state: CampaignState? = nil, treatmentDescription: String? = nil, treatmentName: String? = nil) {
            self.id = id
            self.messageConfiguration = messageConfiguration
            self.schedule = schedule
            self.sizePercent = sizePercent
            self.state = state
            self.treatmentDescription = treatmentDescription
            self.treatmentName = treatmentName
        }

        private enum CodingKeys: String, CodingKey {
            case id = "Id"
            case messageConfiguration = "MessageConfiguration"
            case schedule = "Schedule"
            case sizePercent = "SizePercent"
            case state = "State"
            case treatmentDescription = "TreatmentDescription"
            case treatmentName = "TreatmentName"
        }
    }

    public enum `Type`: String, CustomStringConvertible, Codable {
        case all = "ALL"
        case any = "ANY"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public struct UntagResourceRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ResourceArn", location: .uri(locationName: "resource-arn"), required: true, type: .string), 
            AWSShapeMember(label: "TagKeys", location: .querystring(locationName: "tagKeys"), required: true, type: .list)
        ]
        public let resourceArn: String
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "resource-arn"
            case tagKeys = "tagKeys"
        }
    }

    public struct UpdateAdmChannelRequest: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "ADMChannelRequest"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ADMChannelRequest", required: true, type: .structure), 
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let aDMChannelRequest: ADMChannelRequest
        public let applicationId: String

        public init(aDMChannelRequest: ADMChannelRequest, applicationId: String) {
            self.aDMChannelRequest = aDMChannelRequest
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case aDMChannelRequest = "ADMChannelRequest"
            case applicationId = "application-id"
        }
    }

    public struct UpdateAdmChannelResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "ADMChannelResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ADMChannelResponse", required: true, type: .structure)
        ]
        public let aDMChannelResponse: ADMChannelResponse

        public init(aDMChannelResponse: ADMChannelResponse) {
            self.aDMChannelResponse = aDMChannelResponse
        }

        private enum CodingKeys: String, CodingKey {
            case aDMChannelResponse = "ADMChannelResponse"
        }
    }

    public struct UpdateApnsChannelRequest: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "APNSChannelRequest"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "APNSChannelRequest", required: true, type: .structure), 
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let aPNSChannelRequest: APNSChannelRequest
        public let applicationId: String

        public init(aPNSChannelRequest: APNSChannelRequest, applicationId: String) {
            self.aPNSChannelRequest = aPNSChannelRequest
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case aPNSChannelRequest = "APNSChannelRequest"
            case applicationId = "application-id"
        }
    }

    public struct UpdateApnsChannelResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "APNSChannelResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "APNSChannelResponse", required: true, type: .structure)
        ]
        public let aPNSChannelResponse: APNSChannelResponse

        public init(aPNSChannelResponse: APNSChannelResponse) {
            self.aPNSChannelResponse = aPNSChannelResponse
        }

        private enum CodingKeys: String, CodingKey {
            case aPNSChannelResponse = "APNSChannelResponse"
        }
    }

    public struct UpdateApnsSandboxChannelRequest: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "APNSSandboxChannelRequest"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "APNSSandboxChannelRequest", required: true, type: .structure), 
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let aPNSSandboxChannelRequest: APNSSandboxChannelRequest
        public let applicationId: String

        public init(aPNSSandboxChannelRequest: APNSSandboxChannelRequest, applicationId: String) {
            self.aPNSSandboxChannelRequest = aPNSSandboxChannelRequest
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case aPNSSandboxChannelRequest = "APNSSandboxChannelRequest"
            case applicationId = "application-id"
        }
    }

    public struct UpdateApnsSandboxChannelResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "APNSSandboxChannelResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "APNSSandboxChannelResponse", required: true, type: .structure)
        ]
        public let aPNSSandboxChannelResponse: APNSSandboxChannelResponse

        public init(aPNSSandboxChannelResponse: APNSSandboxChannelResponse) {
            self.aPNSSandboxChannelResponse = aPNSSandboxChannelResponse
        }

        private enum CodingKeys: String, CodingKey {
            case aPNSSandboxChannelResponse = "APNSSandboxChannelResponse"
        }
    }

    public struct UpdateApnsVoipChannelRequest: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "APNSVoipChannelRequest"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "APNSVoipChannelRequest", required: true, type: .structure), 
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let aPNSVoipChannelRequest: APNSVoipChannelRequest
        public let applicationId: String

        public init(aPNSVoipChannelRequest: APNSVoipChannelRequest, applicationId: String) {
            self.aPNSVoipChannelRequest = aPNSVoipChannelRequest
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case aPNSVoipChannelRequest = "APNSVoipChannelRequest"
            case applicationId = "application-id"
        }
    }

    public struct UpdateApnsVoipChannelResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "APNSVoipChannelResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "APNSVoipChannelResponse", required: true, type: .structure)
        ]
        public let aPNSVoipChannelResponse: APNSVoipChannelResponse

        public init(aPNSVoipChannelResponse: APNSVoipChannelResponse) {
            self.aPNSVoipChannelResponse = aPNSVoipChannelResponse
        }

        private enum CodingKeys: String, CodingKey {
            case aPNSVoipChannelResponse = "APNSVoipChannelResponse"
        }
    }

    public struct UpdateApnsVoipSandboxChannelRequest: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "APNSVoipSandboxChannelRequest"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "APNSVoipSandboxChannelRequest", required: true, type: .structure), 
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let aPNSVoipSandboxChannelRequest: APNSVoipSandboxChannelRequest
        public let applicationId: String

        public init(aPNSVoipSandboxChannelRequest: APNSVoipSandboxChannelRequest, applicationId: String) {
            self.aPNSVoipSandboxChannelRequest = aPNSVoipSandboxChannelRequest
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case aPNSVoipSandboxChannelRequest = "APNSVoipSandboxChannelRequest"
            case applicationId = "application-id"
        }
    }

    public struct UpdateApnsVoipSandboxChannelResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "APNSVoipSandboxChannelResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "APNSVoipSandboxChannelResponse", required: true, type: .structure)
        ]
        public let aPNSVoipSandboxChannelResponse: APNSVoipSandboxChannelResponse

        public init(aPNSVoipSandboxChannelResponse: APNSVoipSandboxChannelResponse) {
            self.aPNSVoipSandboxChannelResponse = aPNSVoipSandboxChannelResponse
        }

        private enum CodingKeys: String, CodingKey {
            case aPNSVoipSandboxChannelResponse = "APNSVoipSandboxChannelResponse"
        }
    }

    public struct UpdateApplicationSettingsRequest: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "WriteApplicationSettingsRequest"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string), 
            AWSShapeMember(label: "WriteApplicationSettingsRequest", required: true, type: .structure)
        ]
        public let applicationId: String
        public let writeApplicationSettingsRequest: WriteApplicationSettingsRequest

        public init(applicationId: String, writeApplicationSettingsRequest: WriteApplicationSettingsRequest) {
            self.applicationId = applicationId
            self.writeApplicationSettingsRequest = writeApplicationSettingsRequest
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
            case writeApplicationSettingsRequest = "WriteApplicationSettingsRequest"
        }
    }

    public struct UpdateApplicationSettingsResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "ApplicationSettingsResource"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationSettingsResource", required: true, type: .structure)
        ]
        public let applicationSettingsResource: ApplicationSettingsResource

        public init(applicationSettingsResource: ApplicationSettingsResource) {
            self.applicationSettingsResource = applicationSettingsResource
        }

        private enum CodingKeys: String, CodingKey {
            case applicationSettingsResource = "ApplicationSettingsResource"
        }
    }

    public struct UpdateAttributesRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Blacklist", required: false, type: .list)
        ]
        /// The GLOB wildcard for removing the attributes in the application
        public let blacklist: [String]?

        public init(blacklist: [String]? = nil) {
            self.blacklist = blacklist
        }

        private enum CodingKeys: String, CodingKey {
            case blacklist = "Blacklist"
        }
    }

    public struct UpdateBaiduChannelRequest: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "BaiduChannelRequest"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string), 
            AWSShapeMember(label: "BaiduChannelRequest", required: true, type: .structure)
        ]
        public let applicationId: String
        public let baiduChannelRequest: BaiduChannelRequest

        public init(applicationId: String, baiduChannelRequest: BaiduChannelRequest) {
            self.applicationId = applicationId
            self.baiduChannelRequest = baiduChannelRequest
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
            case baiduChannelRequest = "BaiduChannelRequest"
        }
    }

    public struct UpdateBaiduChannelResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "BaiduChannelResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "BaiduChannelResponse", required: true, type: .structure)
        ]
        public let baiduChannelResponse: BaiduChannelResponse

        public init(baiduChannelResponse: BaiduChannelResponse) {
            self.baiduChannelResponse = baiduChannelResponse
        }

        private enum CodingKeys: String, CodingKey {
            case baiduChannelResponse = "BaiduChannelResponse"
        }
    }

    public struct UpdateCampaignRequest: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "WriteCampaignRequest"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string), 
            AWSShapeMember(label: "CampaignId", location: .uri(locationName: "campaign-id"), required: true, type: .string), 
            AWSShapeMember(label: "WriteCampaignRequest", required: true, type: .structure)
        ]
        public let applicationId: String
        public let campaignId: String
        public let writeCampaignRequest: WriteCampaignRequest

        public init(applicationId: String, campaignId: String, writeCampaignRequest: WriteCampaignRequest) {
            self.applicationId = applicationId
            self.campaignId = campaignId
            self.writeCampaignRequest = writeCampaignRequest
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
            case campaignId = "campaign-id"
            case writeCampaignRequest = "WriteCampaignRequest"
        }
    }

    public struct UpdateCampaignResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "CampaignResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CampaignResponse", required: true, type: .structure)
        ]
        public let campaignResponse: CampaignResponse

        public init(campaignResponse: CampaignResponse) {
            self.campaignResponse = campaignResponse
        }

        private enum CodingKeys: String, CodingKey {
            case campaignResponse = "CampaignResponse"
        }
    }

    public struct UpdateEmailChannelRequest: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "EmailChannelRequest"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string), 
            AWSShapeMember(label: "EmailChannelRequest", required: true, type: .structure)
        ]
        public let applicationId: String
        public let emailChannelRequest: EmailChannelRequest

        public init(applicationId: String, emailChannelRequest: EmailChannelRequest) {
            self.applicationId = applicationId
            self.emailChannelRequest = emailChannelRequest
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
            case emailChannelRequest = "EmailChannelRequest"
        }
    }

    public struct UpdateEmailChannelResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "EmailChannelResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "EmailChannelResponse", required: true, type: .structure)
        ]
        public let emailChannelResponse: EmailChannelResponse

        public init(emailChannelResponse: EmailChannelResponse) {
            self.emailChannelResponse = emailChannelResponse
        }

        private enum CodingKeys: String, CodingKey {
            case emailChannelResponse = "EmailChannelResponse"
        }
    }

    public struct UpdateEndpointRequest: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "EndpointRequest"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string), 
            AWSShapeMember(label: "EndpointId", location: .uri(locationName: "endpoint-id"), required: true, type: .string), 
            AWSShapeMember(label: "EndpointRequest", required: true, type: .structure)
        ]
        public let applicationId: String
        public let endpointId: String
        public let endpointRequest: EndpointRequest

        public init(applicationId: String, endpointId: String, endpointRequest: EndpointRequest) {
            self.applicationId = applicationId
            self.endpointId = endpointId
            self.endpointRequest = endpointRequest
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
            case endpointId = "endpoint-id"
            case endpointRequest = "EndpointRequest"
        }
    }

    public struct UpdateEndpointResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "MessageBody"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "MessageBody", required: true, type: .structure)
        ]
        public let messageBody: MessageBody

        public init(messageBody: MessageBody) {
            self.messageBody = messageBody
        }

        private enum CodingKeys: String, CodingKey {
            case messageBody = "MessageBody"
        }
    }

    public struct UpdateEndpointsBatchRequest: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "EndpointBatchRequest"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string), 
            AWSShapeMember(label: "EndpointBatchRequest", required: true, type: .structure)
        ]
        public let applicationId: String
        public let endpointBatchRequest: EndpointBatchRequest

        public init(applicationId: String, endpointBatchRequest: EndpointBatchRequest) {
            self.applicationId = applicationId
            self.endpointBatchRequest = endpointBatchRequest
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
            case endpointBatchRequest = "EndpointBatchRequest"
        }
    }

    public struct UpdateEndpointsBatchResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "MessageBody"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "MessageBody", required: true, type: .structure)
        ]
        public let messageBody: MessageBody

        public init(messageBody: MessageBody) {
            self.messageBody = messageBody
        }

        private enum CodingKeys: String, CodingKey {
            case messageBody = "MessageBody"
        }
    }

    public struct UpdateGcmChannelRequest: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "GCMChannelRequest"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string), 
            AWSShapeMember(label: "GCMChannelRequest", required: true, type: .structure)
        ]
        public let applicationId: String
        public let gCMChannelRequest: GCMChannelRequest

        public init(applicationId: String, gCMChannelRequest: GCMChannelRequest) {
            self.applicationId = applicationId
            self.gCMChannelRequest = gCMChannelRequest
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
            case gCMChannelRequest = "GCMChannelRequest"
        }
    }

    public struct UpdateGcmChannelResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "GCMChannelResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "GCMChannelResponse", required: true, type: .structure)
        ]
        public let gCMChannelResponse: GCMChannelResponse

        public init(gCMChannelResponse: GCMChannelResponse) {
            self.gCMChannelResponse = gCMChannelResponse
        }

        private enum CodingKeys: String, CodingKey {
            case gCMChannelResponse = "GCMChannelResponse"
        }
    }

    public struct UpdateSegmentRequest: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "WriteSegmentRequest"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string), 
            AWSShapeMember(label: "SegmentId", location: .uri(locationName: "segment-id"), required: true, type: .string), 
            AWSShapeMember(label: "WriteSegmentRequest", required: true, type: .structure)
        ]
        public let applicationId: String
        public let segmentId: String
        public let writeSegmentRequest: WriteSegmentRequest

        public init(applicationId: String, segmentId: String, writeSegmentRequest: WriteSegmentRequest) {
            self.applicationId = applicationId
            self.segmentId = segmentId
            self.writeSegmentRequest = writeSegmentRequest
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
            case segmentId = "segment-id"
            case writeSegmentRequest = "WriteSegmentRequest"
        }
    }

    public struct UpdateSegmentResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "SegmentResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SegmentResponse", required: true, type: .structure)
        ]
        public let segmentResponse: SegmentResponse

        public init(segmentResponse: SegmentResponse) {
            self.segmentResponse = segmentResponse
        }

        private enum CodingKeys: String, CodingKey {
            case segmentResponse = "SegmentResponse"
        }
    }

    public struct UpdateSmsChannelRequest: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "SMSChannelRequest"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string), 
            AWSShapeMember(label: "SMSChannelRequest", required: true, type: .structure)
        ]
        public let applicationId: String
        public let sMSChannelRequest: SMSChannelRequest

        public init(applicationId: String, sMSChannelRequest: SMSChannelRequest) {
            self.applicationId = applicationId
            self.sMSChannelRequest = sMSChannelRequest
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
            case sMSChannelRequest = "SMSChannelRequest"
        }
    }

    public struct UpdateSmsChannelResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "SMSChannelResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SMSChannelResponse", required: true, type: .structure)
        ]
        public let sMSChannelResponse: SMSChannelResponse

        public init(sMSChannelResponse: SMSChannelResponse) {
            self.sMSChannelResponse = sMSChannelResponse
        }

        private enum CodingKeys: String, CodingKey {
            case sMSChannelResponse = "SMSChannelResponse"
        }
    }

    public struct UpdateVoiceChannelRequest: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "VoiceChannelRequest"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string), 
            AWSShapeMember(label: "VoiceChannelRequest", required: true, type: .structure)
        ]
        public let applicationId: String
        public let voiceChannelRequest: VoiceChannelRequest

        public init(applicationId: String, voiceChannelRequest: VoiceChannelRequest) {
            self.applicationId = applicationId
            self.voiceChannelRequest = voiceChannelRequest
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
            case voiceChannelRequest = "VoiceChannelRequest"
        }
    }

    public struct UpdateVoiceChannelResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "VoiceChannelResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "VoiceChannelResponse", required: true, type: .structure)
        ]
        public let voiceChannelResponse: VoiceChannelResponse

        public init(voiceChannelResponse: VoiceChannelResponse) {
            self.voiceChannelResponse = voiceChannelResponse
        }

        private enum CodingKeys: String, CodingKey {
            case voiceChannelResponse = "VoiceChannelResponse"
        }
    }

    public struct VoiceChannelRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Enabled", required: false, type: .boolean)
        ]
        /// If the channel is enabled for sending messages.
        public let enabled: Bool?

        public init(enabled: Bool? = nil) {
            self.enabled = enabled
        }

        private enum CodingKeys: String, CodingKey {
            case enabled = "Enabled"
        }
    }

    public struct VoiceChannelResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", required: false, type: .string), 
            AWSShapeMember(label: "CreationDate", required: false, type: .string), 
            AWSShapeMember(label: "Enabled", required: false, type: .boolean), 
            AWSShapeMember(label: "HasCredential", required: false, type: .boolean), 
            AWSShapeMember(label: "Id", required: false, type: .string), 
            AWSShapeMember(label: "IsArchived", required: false, type: .boolean), 
            AWSShapeMember(label: "LastModifiedBy", required: false, type: .string), 
            AWSShapeMember(label: "LastModifiedDate", required: false, type: .string), 
            AWSShapeMember(label: "Platform", required: false, type: .string), 
            AWSShapeMember(label: "Version", required: false, type: .integer)
        ]
        /// Application id
        public let applicationId: String?
        /// The date that the settings were last updated in ISO 8601 format.
        public let creationDate: String?
        /// If the channel is enabled for sending messages.
        public let enabled: Bool?
        public let hasCredential: Bool?
        /// Channel ID. Not used, only for backwards compatibility.
        public let id: String?
        /// Is this channel archived
        public let isArchived: Bool?
        /// Who made the last change
        public let lastModifiedBy: String?
        /// Last date this was updated
        public let lastModifiedDate: String?
        /// Platform type. Will be "Voice"
        public let platform: String?
        /// Version of channel
        public let version: Int32?

        public init(applicationId: String? = nil, creationDate: String? = nil, enabled: Bool? = nil, hasCredential: Bool? = nil, id: String? = nil, isArchived: Bool? = nil, lastModifiedBy: String? = nil, lastModifiedDate: String? = nil, platform: String? = nil, version: Int32? = nil) {
            self.applicationId = applicationId
            self.creationDate = creationDate
            self.enabled = enabled
            self.hasCredential = hasCredential
            self.id = id
            self.isArchived = isArchived
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedDate = lastModifiedDate
            self.platform = platform
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "ApplicationId"
            case creationDate = "CreationDate"
            case enabled = "Enabled"
            case hasCredential = "HasCredential"
            case id = "Id"
            case isArchived = "IsArchived"
            case lastModifiedBy = "LastModifiedBy"
            case lastModifiedDate = "LastModifiedDate"
            case platform = "Platform"
            case version = "Version"
        }
    }

    public struct VoiceMessage: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Body", required: false, type: .string), 
            AWSShapeMember(label: "LanguageCode", required: false, type: .string), 
            AWSShapeMember(label: "OriginationNumber", required: false, type: .string), 
            AWSShapeMember(label: "Substitutions", required: false, type: .map), 
            AWSShapeMember(label: "VoiceId", required: false, type: .string)
        ]
        /// The message body of the notification, the email body or the text message.
        public let body: String?
        /// Language of sent message
        public let languageCode: String?
        /// Is the number from the pool or messaging service to send from.
        public let originationNumber: String?
        /// Default message substitutions. Can be overridden by individual address substitutions.
        public let substitutions: [String: [String]]?
        /// Voice ID of sent message.
        public let voiceId: String?

        public init(body: String? = nil, languageCode: String? = nil, originationNumber: String? = nil, substitutions: [String: [String]]? = nil, voiceId: String? = nil) {
            self.body = body
            self.languageCode = languageCode
            self.originationNumber = originationNumber
            self.substitutions = substitutions
            self.voiceId = voiceId
        }

        private enum CodingKeys: String, CodingKey {
            case body = "Body"
            case languageCode = "LanguageCode"
            case originationNumber = "OriginationNumber"
            case substitutions = "Substitutions"
            case voiceId = "VoiceId"
        }
    }

    public struct WriteApplicationSettingsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CampaignHook", required: false, type: .structure), 
            AWSShapeMember(label: "CloudWatchMetricsEnabled", required: false, type: .boolean), 
            AWSShapeMember(label: "Limits", required: false, type: .structure), 
            AWSShapeMember(label: "QuietTime", required: false, type: .structure)
        ]
        /// Default campaign hook information.
        public let campaignHook: CampaignHook?
        /// The CloudWatchMetrics settings for the app.
        public let cloudWatchMetricsEnabled: Bool?
        /// The limits that apply to each campaign in the project by default. Campaigns can also have their own limits, which override the settings at the project level.
        public let limits: CampaignLimits?
        /// The default quiet time for the app. Campaigns in the app don't send messages to endpoints during the quiet time.
        /// Note: Make sure that your endpoints include the Demographics.Timezone attribute if you plan to enable a quiet time for your app. If your endpoints don't include this attribute, they'll receive the messages that you send them, even if quiet time is enabled.
        /// When you set up an app to use quiet time, campaigns in that app don't send messages during the time range you specified, as long as all of the following are true:
        /// - The endpoint includes a valid Demographic.Timezone attribute.
        /// - The current time in the endpoint's time zone is later than or equal to the time specified in the QuietTime.Start attribute for the app (or campaign, if applicable).
        /// - The current time in the endpoint's time zone is earlier than or equal to the time specified in the QuietTime.End attribute for the app (or campaign, if applicable).
        /// Individual campaigns within the app can have their own quiet time settings, which override the quiet time settings at the app level.
        public let quietTime: QuietTime?

        public init(campaignHook: CampaignHook? = nil, cloudWatchMetricsEnabled: Bool? = nil, limits: CampaignLimits? = nil, quietTime: QuietTime? = nil) {
            self.campaignHook = campaignHook
            self.cloudWatchMetricsEnabled = cloudWatchMetricsEnabled
            self.limits = limits
            self.quietTime = quietTime
        }

        private enum CodingKeys: String, CodingKey {
            case campaignHook = "CampaignHook"
            case cloudWatchMetricsEnabled = "CloudWatchMetricsEnabled"
            case limits = "Limits"
            case quietTime = "QuietTime"
        }
    }

    public struct WriteCampaignRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AdditionalTreatments", required: false, type: .list), 
            AWSShapeMember(label: "Description", required: false, type: .string), 
            AWSShapeMember(label: "HoldoutPercent", required: false, type: .integer), 
            AWSShapeMember(label: "Hook", required: false, type: .structure), 
            AWSShapeMember(label: "IsPaused", required: false, type: .boolean), 
            AWSShapeMember(label: "Limits", required: false, type: .structure), 
            AWSShapeMember(label: "MessageConfiguration", required: false, type: .structure), 
            AWSShapeMember(label: "Name", required: false, type: .string), 
            AWSShapeMember(label: "Schedule", required: false, type: .structure), 
            AWSShapeMember(label: "SegmentId", required: false, type: .string), 
            AWSShapeMember(label: "SegmentVersion", required: false, type: .integer), 
            AWSShapeMember(label: "TreatmentDescription", required: false, type: .string), 
            AWSShapeMember(label: "TreatmentName", required: false, type: .string), 
            AWSShapeMember(label: "tags", location: .body(locationName: "tags"), required: false, type: .map)
        ]
        /// Treatments that are defined in addition to the default treatment.
        public let additionalTreatments: [WriteTreatmentResource]?
        /// A description of the campaign.
        public let description: String?
        /// The allocated percentage of end users who will not receive messages from this campaign.
        public let holdoutPercent: Int32?
        /// Campaign hook information.
        public let hook: CampaignHook?
        /// Indicates whether the campaign is paused. A paused campaign does not send messages unless you resume it by setting IsPaused to false.
        public let isPaused: Bool?
        /// The campaign limits settings.
        public let limits: CampaignLimits?
        /// The message configuration settings.
        public let messageConfiguration: MessageConfiguration?
        /// The custom name of the campaign.
        public let name: String?
        /// The campaign schedule.
        public let schedule: Schedule?
        /// The ID of the segment to which the campaign sends messages.
        public let segmentId: String?
        /// The version of the segment to which the campaign sends messages.
        public let segmentVersion: Int32?
        /// A custom description for the treatment.
        public let treatmentDescription: String?
        /// The custom name of a variation of the campaign used for A/B testing.
        public let treatmentName: String?
        /// The Tags for the campaign.
        public let tags: [String: String]?

        public init(additionalTreatments: [WriteTreatmentResource]? = nil, description: String? = nil, holdoutPercent: Int32? = nil, hook: CampaignHook? = nil, isPaused: Bool? = nil, limits: CampaignLimits? = nil, messageConfiguration: MessageConfiguration? = nil, name: String? = nil, schedule: Schedule? = nil, segmentId: String? = nil, segmentVersion: Int32? = nil, tags: [String: String]? = nil, treatmentDescription: String? = nil, treatmentName: String? = nil) {
            self.additionalTreatments = additionalTreatments
            self.description = description
            self.holdoutPercent = holdoutPercent
            self.hook = hook
            self.isPaused = isPaused
            self.limits = limits
            self.messageConfiguration = messageConfiguration
            self.name = name
            self.schedule = schedule
            self.segmentId = segmentId
            self.segmentVersion = segmentVersion
            self.treatmentDescription = treatmentDescription
            self.treatmentName = treatmentName
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case additionalTreatments = "AdditionalTreatments"
            case description = "Description"
            case holdoutPercent = "HoldoutPercent"
            case hook = "Hook"
            case isPaused = "IsPaused"
            case limits = "Limits"
            case messageConfiguration = "MessageConfiguration"
            case name = "Name"
            case schedule = "Schedule"
            case segmentId = "SegmentId"
            case segmentVersion = "SegmentVersion"
            case treatmentDescription = "TreatmentDescription"
            case treatmentName = "TreatmentName"
            case tags = "tags"
        }
    }

    public struct WriteEventStream: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DestinationStreamArn", required: false, type: .string), 
            AWSShapeMember(label: "RoleArn", required: false, type: .string)
        ]
        /// The Amazon Resource Name (ARN) of the Amazon Kinesis stream or Firehose delivery stream to which you want to publish events.
        ///  Firehose ARN: arn:aws:firehose:REGION:ACCOUNT_ID:deliverystream/STREAM_NAME
        ///  Kinesis ARN: arn:aws:kinesis:REGION:ACCOUNT_ID:stream/STREAM_NAME
        public let destinationStreamArn: String?
        /// The IAM role that authorizes Amazon Pinpoint to publish events to the stream in your account.
        public let roleArn: String?

        public init(destinationStreamArn: String? = nil, roleArn: String? = nil) {
            self.destinationStreamArn = destinationStreamArn
            self.roleArn = roleArn
        }

        private enum CodingKeys: String, CodingKey {
            case destinationStreamArn = "DestinationStreamArn"
            case roleArn = "RoleArn"
        }
    }

    public struct WriteSegmentRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Dimensions", required: false, type: .structure), 
            AWSShapeMember(label: "Name", required: false, type: .string), 
            AWSShapeMember(label: "SegmentGroups", required: false, type: .structure), 
            AWSShapeMember(label: "tags", location: .body(locationName: "tags"), required: false, type: .map)
        ]
        /// The segment dimensions attributes.
        public let dimensions: SegmentDimensions?
        /// The name of segment
        public let name: String?
        /// A segment group, which consists of zero or more source segments, plus dimensions that are applied to those source segments. Your request can only include one segment group. Your request can include either a SegmentGroups object or a Dimensions object, but not both.
        public let segmentGroups: SegmentGroupList?
        /// The Tags for the segments.
        public let tags: [String: String]?

        public init(dimensions: SegmentDimensions? = nil, name: String? = nil, segmentGroups: SegmentGroupList? = nil, tags: [String: String]? = nil) {
            self.dimensions = dimensions
            self.name = name
            self.segmentGroups = segmentGroups
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case dimensions = "Dimensions"
            case name = "Name"
            case segmentGroups = "SegmentGroups"
            case tags = "tags"
        }
    }

    public struct WriteTreatmentResource: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "MessageConfiguration", required: false, type: .structure), 
            AWSShapeMember(label: "Schedule", required: false, type: .structure), 
            AWSShapeMember(label: "SizePercent", required: false, type: .integer), 
            AWSShapeMember(label: "TreatmentDescription", required: false, type: .string), 
            AWSShapeMember(label: "TreatmentName", required: false, type: .string)
        ]
        /// The message configuration settings.
        public let messageConfiguration: MessageConfiguration?
        /// The campaign schedule.
        public let schedule: Schedule?
        /// The allocated percentage of users for this treatment.
        public let sizePercent: Int32?
        /// A custom description for the treatment.
        public let treatmentDescription: String?
        /// The custom name of a variation of the campaign used for A/B testing.
        public let treatmentName: String?

        public init(messageConfiguration: MessageConfiguration? = nil, schedule: Schedule? = nil, sizePercent: Int32? = nil, treatmentDescription: String? = nil, treatmentName: String? = nil) {
            self.messageConfiguration = messageConfiguration
            self.schedule = schedule
            self.sizePercent = sizePercent
            self.treatmentDescription = treatmentDescription
            self.treatmentName = treatmentName
        }

        private enum CodingKeys: String, CodingKey {
            case messageConfiguration = "MessageConfiguration"
            case schedule = "Schedule"
            case sizePercent = "SizePercent"
            case treatmentDescription = "TreatmentDescription"
            case treatmentName = "TreatmentName"
        }
    }

}